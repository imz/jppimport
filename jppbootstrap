#!/usr/bin/perl -w

package RPM::SpecFile::Bootstrap;

use Getopt::Long;
use RPM::Source::Macros;
use File::Path;
use strict;
use warnings;

my $release='0.1';
my $verbose=0;
my $outdir='.';
my $changelog='- bootstrap pack of jars created with jppbootstrap script
- temporary package to satisfy circular dependencies';
my $result = GetOptions (
		      "changelog=s"   => \$changelog,
		      "outdir=s"   => \$outdir,
		      "release=s"   => \$release,
		      "verbose+"  => \$verbose);

die unless @ARGV;

my $macros=RPM::Source::Macros->new();
my $packager=$macros->macro_subst('%{packager}');
$packager=undef if $packager eq '%{packager}';

map {&package($_)} @ARGV;

sub package {
    my $rpmfile=shift;
    my $jpp=RPM::SpecFile::Bootstrap->new(RPM=>$rpmfile);

    my $trippletname=$jpp->query('NAME')."-".$jpp->query('VERSION')."-".$jpp->query('RELEASE');
    my $tmpdir = $trippletname.$$;
    my $SOURCESDIR="$tmpdir/SOURCES";
    my $SPECSDIR="$tmpdir/SPECS";
    my $specfile=$SPECSDIR."/".$jpp->query('NAME').'.spec';
    mkdir $tmpdir;
    mkdir $SOURCESDIR;
    mkdir $SPECSDIR;
    
    `rpm2cpio $rpmfile > $SOURCESDIR/$trippletname.cpio`;

    open SPEC, '>', $specfile;

    foreach my $tag qw/
NAME
VERSION
SUMMARY
EPOCH
LICENSE
URL
/ {
    my $tagval=$jpp->query($tag);
    print SPEC ucfirst(lc($tag)).": ".$tagval."\n" if defined $tagval && $tagval ne '(none)';
}
    print SPEC "Packager: $packager\n" if $packager;

    my $pkgname=$jpp->query('NAME');

    foreach my $tag qw/
PROVIDENAME
REQUIRENAME
/ {
    my @tagval=$jpp->multiquery($tag);
    my $tagname=ucfirst(lc($tag));
    $tagname=~s/name/s/;
    foreach my $val (@tagval) {
	print SPEC $tagname.": ".$val."\n" if $val ne $pkgname;
    }
}

    $release='alt'.$release unless $release=~/^alt/;
    $release=$release.'jpp' unless $release=~/jpp/;
    print SPEC '
BuildArch: noarch
Group: Development/Java
Release: '.$release.'
Source: '.$trippletname.".cpio\n\n";

    foreach my $tag qw/DESCRIPTION
/ {
    my $query = $jpp->query($tag);
    print SPEC '%'.lc($tag)."\n".$query."\n" if $query ne '';
}

    print SPEC q!
# sometimes commpress gets crazy (see maven-scm-javadoc for details)
%set_compress_method none
%prep
cpio -idmu --quiet --no-absolute-filenames < %{SOURCE0}

%build
cpio --list < %{SOURCE0} | sed -e 's,^\.,,' > %name-list

%install
mkdir -p $RPM_BUILD_ROOT
for i in usr var etc; do
[ -d $i ] && mv $i $RPM_BUILD_ROOT/
done
!;

foreach my $sec qw/
PREIN
PREUN
POSTIN
POSTUN
/ {
    my $secname=lc($sec);
    $secname=~s/in$//;
    my $val=$jpp->query($sec);
    print SPEC '
%'.$secname."\n".$val."\n" if $val and $val ne "(none)";
}


print SPEC q!

%files -f %name-list

%changelog
!;

system ('add_changelog', '-e',$changelog,$specfile);
mkpath([$outdir]) unless -d $outdir;
`rpmbuild --define '_sourcedir $SOURCESDIR' --define '_srcrpmdir $outdir' -bs $specfile`;
`rm -r $tmpdir`;
}

sub new {
    my $class=shift;
    my $self = {
	@_,
    };
    return bless $self, $class;
}

sub eval {
    my $tag = shift;
    #%packager
    return `rpmquery --eval '$tag' 2>/dev/null`

}

sub query {
    my $self=shift;
    my $tag=shift;
    my $query=`rpmquery -p --queryformat '\%{$tag}' $self->{RPM}`;
    chomp $query;
    return $query;
}

sub multiquery {
    my $self=shift;
    my $tag=shift;
    return grep {$_ and $_!~/^.+\(/} split (/\s+/, `rpmquery -p --queryformat '[\%{$tag}\n]' $self->{RPM}`);
}


__END__
SERIAL
ARCH
GROUP
RELEASE
COPYRIGHT
SOURCE
PATCH
PREIN
POSTIN
PREUN
POSTUN
PROVIDENAME
PROVIDES
CONFLICTFLAGS
REQUIRENAME
REQUIREVERSION
CONFLICTFLAGS
CONFLICTNAME
CONFLICTVERSION
OBSOLETENAME
OBSOLETES
PROVIDEFLAGS
PROVIDEVERSION
OBSOLETEFLAGS
OBSOLETEVERSION

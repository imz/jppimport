#!/usr/bin/perl -w

package RPM::SpecFile::Bootstrap;

use Getopt::Long;
use RPM::Source::Editor;
use RPM::Source::Macros;
use File::Path;
use strict;
use warnings;

my $release='0.1';
my $verbose=0;
my $outdir='.';
my $changelog='- bootstrap pack of jars created with jppbootstrap script
- temporary package to satisfy circular dependencies';
my $force_cleanup;
my (@skiprequires,@skipprovides);
my (@addprovides,@addrequires,@addobsoletes,$opt_epoch);
my ($altrpm,$altspec);
my $result = GetOptions (
		      "changelog=s"   => \$changelog,
		      "outdir=s"   => \$outdir,
		      "release=s"   => \$release,
		      "alt=s"   => \$altrpm,
		      "parent=s"   => \$altrpm,
		      "epoch=s"   => \$opt_epoch,
		      "skip-requires=s"   => \@skiprequires,
		      "skip-provides=s"   => \@skipprovides,
		      "add-provides=s"   => \@addprovides,
		      "add-requires=s"   => \@addrequires,
		      "add-obsoletes=s"   => \@addobsoletes,
		      "verbose+"  => \$verbose);

die unless @ARGV;

my $macros=RPM::Source::Macros->new();
my $packager=$macros->macro_subst('%{packager}');
$packager=undef if $packager eq '%{packager}';

my %skip;
$skip{PROVIDENAME}={map {$_=>1} split(',',join(',',@skipprovides))};
$skip{REQUIRENAME}={map {$_=>1} split(',',join(',',@skiprequires))};

foreach (@ARGV) {
    die "Oops: $_ not found" unless -e $_;
    &package($_);
}

sub print_tag {
    my ($fn,$tag,$tagval)=@_;
    print $fn ucfirst(lc($tag)).": ".$tagval."\n" if defined $tagval && $tagval ne '(none)';
}

sub package {
    my $rpmfile=shift;
    my $jpp=RPM::SpecFile::Bootstrap->new(RPM=>$rpmfile);
    my $alt;
    if ($altrpm || $altspec) {
	$alt=RPM::Source::Editor->new(SOURCERPM => $altrpm, SPECFILE => $altspec, VERBOSE=> $verbose);
    }

    my $trippletname=$jpp->query('NAME')."-".$jpp->query('VERSION')."-".$jpp->query('RELEASE');
    my $tmpdir = $trippletname.$$;
    my $SOURCESDIR="$tmpdir/SOURCES";
    my $SPECSDIR="$tmpdir/SPECS";
    my $specfile=$SPECSDIR."/".$jpp->query('NAME').'.spec';
    mkdir $tmpdir;
    mkdir $SOURCESDIR;
    mkdir $SPECSDIR;
    
    `rpm2cpio $rpmfile > $SOURCESDIR/$trippletname.cpio`;

    open SPEC, '>', $specfile;

    foreach my $tag (qw/
NAME
VERSION
SUMMARY
LICENSE
URL
/) {
    my $tagval=$jpp->query($tag);
    &print_tag(\*SPEC, $tag,$tagval);
}

    my $epoch=$jpp->query('EPOCH');
    if ($alt) {
	my $altepoch=$alt->main_section->get_tag('Epoch');
	if (defined $altepoch and (not defined $epoch or $epoch eq '(none)' or $altepoch> $epoch)) {
	    $epoch=$altepoch;
	}
    }
    $epoch=$opt_epoch if defined $opt_epoch;
    &print_tag(\*SPEC, 'EPOCH',$epoch);

    print SPEC "Packager: $packager\n" if $packager;

    my $pkgname=$jpp->query('NAME');

    foreach my $triplet (
[qw/PROVIDENAME PROVIDEFLAGS PROVIDEVERSION/]
	) {
	my @tagval=$jpp->triquery(@$triplet);
	@tagval=grep {$_!~/^.+\(/ or /^mvn\(/ or /^osgi\(/} @tagval;
	my $tag=$triplet->[0];
	#print STDERR "DEBUG: $triplet->[0]: ",join(' ',@tagval),"\n";
	my $tagname=ucfirst(lc($tag));
	$tagname=~s/name/s/;
	foreach my $val (@tagval) {
	    print SPEC $tagname.": ".$val."\n" if $val ne $pkgname and not $skip{$tag}->{$val};
	}
    }

    foreach my $tag (qw/
REQUIRENAME
/) {
    my @tagval=$jpp->multiquery($tag);
    @tagval=grep {$_!~/^.+\(/ or /^mvn\(/ or /^osgi\(/} @tagval;
    #print STDERR "DEBUG: $tag: ",join(' ',@tagval),"\n";
    my $tagname=ucfirst(lc($tag));
    $tagname=~s/name/s/;
    foreach my $val (@tagval) {
	print SPEC $tagname.": ".$val."\n" if $val ne $pkgname and not $skip{$tag}->{$val};
    }
}


    $release='alt'.$release unless $release=~/^alt/;
    $release=$release.'jpp' unless $release=~/jpp/;
    print SPEC '
BuildArch: noarch
Group: Development/Java
Release: '.$release.'
Source: '.$trippletname.".cpio\n\n";

    print SPEC 'Provides: '.join(' ',@addprovides)."\n" if @addprovides;
    print SPEC 'Requires: '.join(' ',@addrequires)."\n" if @addrequires;
    print SPEC 'Obsoletes: '.join(' ',@addobsoletes)."\n" if @addobsoletes;

    foreach my $tag (qw/DESCRIPTION
/) {
    my $query = $jpp->query($tag);
    print SPEC '%'.lc($tag)."\n".$query."\n" if $query ne '';
}

    print SPEC q!
# sometimes commpress gets crazy (see maven-scm-javadoc for details)
%set_compress_method none
%prep
cpio -idmu --quiet --no-absolute-filenames < %{SOURCE0}

%build
cpio --list < %{SOURCE0} | sed -e 's,^\.,,' > %name-list

%install
mkdir -p $RPM_BUILD_ROOT
for i in usr var etc; do
[ -d $i ] && mv $i $RPM_BUILD_ROOT/
done
!;

#PRETRANS
#POSTTRANS

    foreach my $sec (qw/
PREIN
PREUN
POSTIN
POSTUN
/) {
    my $secname=lc($sec);
    $secname=~s/in$//;
    my $val=$jpp->query($sec);
    print SPEC '
%'.$secname."\n".$val."\n" if $val and $val ne "(none)";
}


    print SPEC q!

%files -f %name-list

%changelog
!;
if ($alt) {
    my @changelog_alt=@{$alt->get_section('changelog')->get_bodyref()};
    shift @changelog_alt; # %changelog header
    print SPEC @changelog_alt;
}

    system ('add_changelog', '-e',$changelog,$specfile)==0 || &cleanup_and_exit($tmpdir);
    mkpath([$outdir]) unless -d $outdir;
    system ('rpmbuild', '--define', '_sourcedir '.$SOURCESDIR, '--define', '_srcrpmdir '.$outdir, '-bs', $specfile)==0 || &cleanup_and_exit($tmpdir);
    &cleanup($tmpdir);
}

sub cleanup {
    my $tmpdir=shift;
    `rm -r $tmpdir`;
}

sub cleanup_and_exit {
    my $tmpdir=shift;
    &cleanup($tmpdir) if $force_cleanup;
    exit 1;
}

sub new {
    my $class=shift;
    my $self = {
	@_,
    };
    return bless $self, $class;
}

sub eval {
    my $tag = shift;
    #%packager
    return `rpmquery --eval '$tag' 2>/dev/null`

}

sub query{
    my $self=shift;
    my $tag=shift;
    my $query=`rpmquery -p --queryformat '\%{$tag}' $self->{RPM}`;
    chomp $query;
    return $query;
}

sub multiquery {
    my $self=shift;
    my $tag=shift;
    return grep {$_} split (/\s+/, `rpmquery -p --queryformat '[\%{$tag}\n]' $self->{RPM}`);
}

sub triquery {
    my ($self,$tag1,$tag2,$tag3)=@_;
    my @triplets=grep {$_} split (/\n/, `rpmquery -p --queryformat '[\%{$tag1} %{$tag2} %{$tag3}\n]' $self->{RPM}`);
    my @out;
    foreach my $triplet (@triplets) {
	my @triple=split (/\s+/, $triplet);
	my $rel=&__rpmflag_to_string($triple[1]);
	if ($rel) {
	    push @out, $triple[0].' '.$rel.' '.$triple[2];
	} else {
	    push @out, $triple[0];
	}
    }
    return @out;
}

sub __rpmflag_to_string {
    my $flag=shift;
    $flag||=0;
    $flag &= 0xf;
    return '' if $flag == 0;
    return '<' if $flag == 2;
    return '>' if $flag == 4;
    return '=' if $flag == 8;
    return '<=' if $flag == 10;
    return '>=' if $flag == 12;
    return '';
}

__END__

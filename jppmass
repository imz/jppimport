#!/usr/bin/perl -w

use Carp;
use Getopt::Long;
use strict;

my $verbose;
my $ALTPATH='~/hasher/repo/SRPMS.hasher:~/hasher/repo/SRPMS.hasher.0:~/hasher/repo/SRPMS.hasher.S:/var/ftp/pub/Linux/ALT/apt-java-Sisyphus/SRPMS.java:/var/ftp/pub/Linux/ALT/Sisyphus/files/SRPMS:/var/ftp/pub/Linux/ALT/Sisyphus/orphaned:/var/ftp/pub/Linux/ALT/5.1/branch/files/SRPMS';
my $JPPPATH='/var/ftp/pub/Linux/jpackage/5.0-updates/generic/free/SRPMS:/var/ftp/pub/Linux/jpackage/5.0/generic/free/SRPMS:/var/ftp/pub/Linux/jpackage/5.0/redhat-el-5.0/free/SRPMS:/var/ftp/pub/Linux/jpackage/5.0/fedora-9/free/SRPMS:/var/ftp/pub/Linux/jpackage/1.7/generic/free/SRPMS';




my $OUTDIR="./OUT";
my ($changelog, $jvm, $nobz2, $nozip, $release,$epoch, $rename);
my $strategy = 'alt2jpp';

my $result = GetOptions ("jpp=s" => \$JPPPATH,
			 "alt=s"   => \$ALTPATH,
			 "out=s" => \$OUTDIR,
			 "changelog=s"   => \$changelog,
			 "strategy=s" => \$strategy,
			 "jvm=s" => \$jvm,
			 "nobz2" => \$nobz2,
			 "nozip" => \$nozip,
			 "rename=s"   => \$rename,
			 "release=s"   => \$release,
			 "epoch=s"   => \$epoch,
			 "verbose"  => \$verbose);
my ($alt,$jpp);

if (! &is_valid_pathspec($ALTPATH) || ! &is_valid_pathspec($JPPPATH)) {
    print "usage [ options ] [ list of rpms/names ]
options:
--jpp /path/to/jpackage/src/RPMS:/other/path
--alt /path/to/altlinux/src/RPMS:/other/path1:/other/path2
--out /path/to/output_dir (default is $OUTDIR)
--changelog '- changelog entry'
--strategy 'strategy' of mass operations (default is $strategy)

usage examples:
upgrade all alt java packages using jpackage
jppmass --alt /var/ftp/pub/Sisyphus/files/SRPMS --jpp /var/ftp/pub/jpackage/1.7/generic/free/SRPMS
";
    exit (64);
}

my @ALTPATH=&path_to_array($ALTPATH);
my @JPPPATH=&path_to_array($JPPPATH);

my $jpptoolsdir=&dirname($0);
my $jppimport="$jpptoolsdir/jppimport";

mkdir $OUTDIR unless -e $OUTDIR;

my @packages = @ARGV;

my %JPPSKIP=map {$_ => 1} qw/gnu.trove xerces-j2 maven-plugin-itest
apache-axiom neethi burlap3 hessian3

useless:
daytrader

fractalish:
jorm
jorm-rdb-adapter
medor
perseus-cache
perseus-concurrency
perseus-persistence
perseus-pool

dead-or-deprecated:
maven2-stylus-skin
maven2-default-skin
maven2-classic-skin
(appeared_again)saxon7

jetty6-core

java_cup  --by_java-cup--
avalon-excalibur

excalibur-avalon-logkit
excalibur-component
excalibur-cornerstone-connection-api
excalibur-cornerstone-connection-impl
excalibur-cornerstone-datasources-api
excalibur-cornerstone-datasources-impl
excalibur-cornerstone-scheduler-api
excalibur-cornerstone-scheduler-impl
excalibur-cornerstone-sockets-api
excalibur-cornerstone-sockets-impl
excalibur-cornerstone-store-api
excalibur-cornerstone-store-impl
excalibur-cornerstone-threads-api
excalibur-cornerstone-threads-impl
excalibur-datasource
excalibur-event-api
excalibur-event-impl
excalibur-fortress-container-api
excalibur-fortress-meta
excalibur-instrument-api
excalibur-instrument-client
excalibur-instrument-mgr-api
excalibur-instrument-mgr-http
excalibur-instrument-mgr-impl
excalibur-lifecycle-api
excalibur-lifecycle-impl
excalibur-logger
excalibur-pool-api
excalibur-pool-impl
excalibur-pool-instrumented
excalibur-testcase
excalibur-thread-api
excalibur-thread-impl
excalibur-thread-instrumented
/
#apache-axiom by ws-commons-axiom
#neethi by ws-commons-neethi
;

# crimson = crimson fields battle game
our @ALTSKIPEXTRA=qw/jpackage-utils/;
#jakarta-commons-cli-2.0-alt0.1.src.rpm
#}

#asm asm2
#jakarta-commons-beanutils-16 jakarta-commons-beanutils16
#jakarta-regexp regexp
#owanttask objectweb-anttask
#stylebook xml-stylebook
#xalan-j xalan-j2
#excalibur-logkit excalibur-avalon-logkit
#stax-bea bea-stax
#jakarta-servletapi4 servletapi4
#wagon maven-wagon
#beanshell bsh2
#jaf sun-jaf
#javamail sun-mail
#jakarta-commons-cli-1 jakarta-commons-cli
#xerces-j xerces-j2
our %ALT2JPPMAP=qw/
jakarta-crimson crimson
jsmc smc
sg-jal jal
lucene2 lucene
/;
# not so simple... hands required!
#jsvc jakarta-commons-daemon

our %JPP2ALTMAP= reverse (%ALT2JPPMAP);

our @ALTSKIPMULTISRPMS=qw/
xml-commons-external xml-commons-resolver
/;
#jakarta-commons-jelly-tags-ant
#jakarta-commons-jelly-tags-define
#jakarta-commons-jelly-tags-util
#jakarta-commons-jelly-tags-xml
#xml-commons xml-commons #xml-commons-external #xml-commons-resolver
##epoch+1
#xmldb-api
#isorelax

our @ALTSKIPNOJPP=qw/
drawswf
eclipse-build-utils
je
jed
jikes
xsdlib
/;

our %ALTSKIP = map {$_=>1} @ALTSKIPMULTISRPMS, @ALTSKIPNOJPP, @ALTSKIPEXTRA;

if ($strategy eq 'alt2jpp') {
    &alt2jpp();
} elsif ($strategy eq 'altup') {
    &altup();
} elsif ($strategy eq 'jppskipalt') {
    &jppskipalt();
} else {
    &alt2jpp();
}



sub alt2jpp {
    foreach my $name (@packages) {
	next if $JPPSKIP{$name};
	next if $ALTSKIP{$name};
	my ($altname,$altrpm)=&get_name_and_rpm($name,\@ALTPATH);
	print STDERR "WARNING: alt RPM $altname not found.\n" unless $altrpm;
	$name=$ALT2JPPMAP{$altname} if $ALT2JPPMAP{$altname};
	my $jpprpm = &find_rpm($name, @JPPPATH);
#	print STDERR "found RPM $jpprpm for $name.\n";
	&run_jppimport($name,$jpprpm,$altrpm);
    }
}

sub altup {
    foreach my $name (@packages) {
	next if $ALTSKIP{$name};
	my ($altname,$altrpm)=&get_name_and_rpm($name,\@ALTPATH);
	print STDERR "note: alt RPM $altname not found.\n" unless $altrpm;
	next unless $altrpm;
	$name=$ALT2JPPMAP{$altname} if $ALT2JPPMAP{$altname};
	my $jpprpm = &find_rpm($name, @JPPPATH);
#	print STDERR "found RPM $jpprpm for $name.\n";
	&run_jppimport($name,$jpprpm,$altrpm) if &alt_jpp_rpmvercmp($altrpm, $jpprpm) <0;
    }
}

sub jppskipalt {
    foreach my $name (@packages) {
	next if $JPPSKIP{$name};
	next if $JPP2ALTMAP{$name};
	my $altrpm = &find_rpm($name, @ALTPATH);
	print STDERR "found alt RPM $altrpm for $name.\n" if $altrpm;
	next if $altrpm and $altrpm!~/orphaned/;
	my $jpprpm = &find_rpm($name, @JPPPATH);
#	print STDERR "found RPM $jpprpm for $name.\n";
	&run_jppimport($name,$jpprpm,$altrpm);
    }
}

sub get_name_and_rpm {
    my $name=shift;
    my $PATHPtr=shift;
    my $rpm=$name;
    if ($name=~/.src.rpm$/) {
	$name=&get_rpm_name($rpm);
    } else {
	$rpm = &find_rpm($name, @$PATHPtr);
    }
    return $name, $rpm;
}

sub run_jppimport {
    my ($name, $jpprpm, $altrpm)=@_;
    my $importcmd="$jppimport --outdir $OUTDIR";
    $importcmd.=" --changelog '$changelog'" if ($changelog);
    $importcmd.=" --release '$release'" if ($release);
    $importcmd.=" --rename '$rename'" if ($rename);
    $importcmd.=" --epoch '$epoch'" if (defined $epoch);
    $importcmd.=" --alt $altrpm" if ($altrpm);
    $importcmd.=" --jvm $jvm" if ($jvm);
    $importcmd.=" --nobz2" if ($nobz2);
    $importcmd.=" --nozip" if ($nozip);
    if ($jpprpm) {
	$importcmd.=" --jpp $jpprpm";
    } else {
	print STDERR "FATAL: jpp RPM $name not found.\n";
	return;
    }

    my $hook="$jpptoolsdir/hooks/$name.pl";
    $importcmd.=" --hook $hook" if (-e $hook);
    print "$importcmd\n";
    print `$importcmd`,"---*---\n";
}

sub path_to_array {
    my $paths=shift;
    my @path;
    foreach (split(':',$paths)) {
	if ($_ eq '') {
	    $_ = '.';
	} elsif (/^~/) {
	    s/^~/$ENV{HOME}/;
	}
	push @path, $_ if -d $_;
    }
    return @path;
}

sub is_valid_pathspec {
    return scalar &path_to_array(shift());
}

sub get_rpm_name {
    my $rpm=shift;
    my $name=`rpmquery --queryformat '\%{NAME}' -p $rpm`;
    chomp $name;
    return $name;
}

sub alt_jpp_rpmvercmp {
    my ($altrpm, $jpprpm) =@_;
    return -1 unless $altrpm;
    return 1 unless $jpprpm;
    my $altversion=&get_rpm_version($altrpm);
    my $altrelease=&get_rpm_release($altrpm);
    my $jppversion=&get_rpm_version($jpprpm);
    my $jpprelease=&get_rpm_release($jpprpm);
    my $cmp = $altversion cmp $jppversion;
    if ($cmp!=0) {
	$cmp=&rpmvercmp($altversion, $jppversion);
	print STDERR "$altversion rpmcmp $jppversion = $cmp\n" if $verbose;
    }
    return $cmp if $cmp !=0;
    if ($altrelease=~/^alt([^_]+)_(.+jpp)(\d.\d)$/) {
	$cmp =$2 cmp $jpprelease;
	print STDERR "$2 cmp $jpprelease = $cmp\n" if $verbose;
	return $2 cmp $jpprelease;
    }
    return -1;
}

sub get_rpm_version {
    my $rpm=shift;
    my $name=`rpmquery --queryformat '\%{VERSION}' -p $rpm`;
    chomp $name;
    return $name;
}

sub get_rpm_release {
    my $rpm=shift;
    my $name=`rpmquery --queryformat '\%{RELEASE}' -p $rpm`;
    chomp $name;
    return $name;
}

sub rpmvercmp {
    my $cmp = `rpmvercmp $_[0] $_[1]`;
    chomp $cmp;
    return $cmp;
}

sub find_rpm {
    my $name=shift;
    for my $path (@_) {
	for my $rpm (reverse(glob "$path/$name-*.src.rpm")) {
#	print STDERR "trying $rpm for $name\n";
	    return $rpm if ($name eq &get_rpm_name($rpm));
	}
    }
    return;
}

sub dirname {
    my @path= split('/',$_[0]);
    pop @path;
    return join('/',@path);
}

#!/usr/bin/perl -w

#use strict;
use warnings;
use Carp;
use Getopt::Long;
use RPM::Source::Editor;
use File::Basename;

my ($jpprpm,$altrpm,$jppspec,$altspec,$hook,$changelog,$release,$nobz2,$jvm);
my $verbose=1;
my $outputdir='.';
my $patchdir=dirname($0)."/patches";

my $result = GetOptions ("jpp=s" => \$jpprpm,
		      "alt=s"   => \$altrpm,
		      "jvm=s" => \$jvm,
		      "jppspec=s" => \$jppspec,
		      "altspec=s"   => \$altspec,
		      "outdir=s"   => \$outputdir,
		      "hook=s"   => \$hook,
		      "changelog=s"   => \$changelog,
		      "release=s"   => \$release,
		      "nobz2"   => \$nobz2,
		      "verbose+"  => \$verbose);
my ($alt,$jpp);

if (! $jpprpm && ! $jppspec) {
    print "ERROR: one of --jpp | --jppspec is required!\n";
    print "options:
--jpp /path/to/jpackage.src.rpm
--alt /path/to/altlinux.src.rpm
--jppspec /path/to/jpackage.spec
--altspec /path/to/altlinux.spec
--hook /path/to/hook to be called on resulting spec file
--jvm jvm JVM required for the build. by default, it is java-1.4.2.
  values are: 4 5 6 4.2 5.0 6.0
--out /path/to/output_dir
--changelog '- message'
--release 'release' - if we need to adjust the package's release

usage examples:
* convert srpm:
jppimport --alt Sisyphus/antlr-2.7.6-alt1.src.rpm --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm
* convert srpm without history:
jppimport --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm --srpmdir ~/OUT
* convert spec:
jppimport --altspec antlr.spec --jppspec jpackage/1.7/generic/free/SPECS/antlr.spec
";
    exit (64);
}

$jpp=RPM::Source::Editor->new(SOURCERPM => $jpprpm, SPECFILE=> $jppspec, OUTPUTDIR=> $outputdir, PATCHDIR=>$patchdir, VERBOSE=> $verbose, NOBZ2=>$nobz2, CHANGELOG=>'- converted from JPackage by jppimport script');

print STDERR "entering alt_generic_fixes\n" if $verbose>1;
&alt_generic_fix($jpp);
print STDERR "done alt_generic_fixes\n" if $verbose>1;
&jpp_specific_fix($jpp);
print STDERR "done jpp_specific_fixes\n" if $verbose>1;

my $altrel="alt1";
my $jpprel = $jpp->get_section('package','')->get_tag('Release');
my $jppver = $jpp->get_section('package','')->get_tag('Version');

# $jpprel_branch is used to keep branch of fedora or mandriva
my $jpprel_branch='';

# for fedora-based imports (hack :()
if ($jpprel=~/\%\{\?dist\}/) {
    $jpprel=~s/\%\{\?dist\}//;
    $jpprel=~s/jpp(\.\d+)?//;
    $jpprel_branch=$1 if $1;
    $jpprel.=q'jpp';
}

if ($altrpm || $altspec) {
    $alt=RPM::Source::Editor->new(SOURCERPM => $altrpm, SPECFILE => $altspec, VERBOSE=> $verbose);
    $altrel = $alt->get_section('package','')->get_tag('Release');
    $altver = $alt->get_section('package','')->get_tag('Version');
    my $vercmp = `rpmvercmp $altver $jppver`;
    chomp $vercmp;
    $jpp->get_section('changelog')->set_body($alt->get_section('changelog')->get_body());
    if ($altrel=~/^alt([^_]+)_(.+jpp)(\d.\d)$/) {
	my $rel = $1;
	my $jppfrom = $2;
	# hack -- cleanup (undefined in jpp) macro in alt release:
	$rel=~s/.?\%\w+//g;
	$rel=~s/.?\%\{\w+\}+//g;
	if ($rel=~/^0\./ or $vercmp != 0) {
	    $rel=1;
	} elsif ($jppfrom eq $jpprel) {
	    $rel=~/^(\d+)/;
	    $rel=$1+1;
	}
	$altrel='alt'.$rel;
    } else {
	$altrel=~s/.?\%\w+//g;
	$altrel=~s/.?\%\{\w+\}+//g;
	$altrel='alt1' if $altrel=~/^alt0\./ or $vercmp != 0;
    }
    $alt->cleanup();
}

my $newrel = $altrel.$jpprel_branch."_".$jpprel;
if ($newrel=~/jpp$/) {
    if ($jvm and $jvm =~ /^5/) {
	$newrel .= "5.0";
    } else {
	$newrel .= "1.7";
    }
}

$newrel=$release if ($release);
$jpp->get_section('package','')->set_tag('Release',$newrel);

# our -- hack ?
our $jpptoolsdir=dirname($0);
# for cross-references in hooks
push @INC, $jpptoolsdir."/hooks";

if (not $hook) {
    # looking for default hook
    my $name = $jpp->get_section('package','')->get_tag('Name');
    my $defhook="$jpptoolsdir/hooks/$name.pl";
    # macro_expansion should be here
    #print "looking for default hook $defhook\n";
    $hook = $defhook if (-e $defhook);
}
if ($hook) {
    our @SPECHOOKS;
    our $spechook;
    require $hook;
    if ($spechook or @SPECHOOKS) {
	$jpp->{WARN_NOTAPPLIED}++;
	map {&$_($jpp,$alt)} @SPECHOOKS;
	&$spechook($jpp,$alt) if $spechook;
	$jpp->{WARN_NOTAPPLIED}--;
    } else {
	die "script $hook does not have a valid hook!\n";
    }
}

if ($changelog) {
    $jpp->set_changelog($changelog);
}

print $jpp->get_spec() if $jppspec or $verbose>1;
$jpp->write_rpm() if $jpprpm;
$jpp->cleanup();

my $TODO=qq~
%if %{native} %if ! %{gcj_support}
BuildRequires:  %{_bindir}/gcj, %{__perl}, 
~;


sub jpp_specific_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    my $main_sec=$rpm->get_section('package','');

    if (not $main_sec->match(qr'BuildRequires: jpackage-.+-compat')) {
	my $jppcompat='1.4';
	if ($jvm) {
	    if ($jvm =~ /^4/) {
		$jppcompat='1.4';
	    } elsif ($jvm =~ /^5/) {
		$jppcompat='1.5';
	    } elsif ($jvm =~ /^6/) {
		$jppcompat='1.6';
	    } else {
		$jppcompat='generic';
	    }
	}
	$main_sec->unshift_body("BuildRequires: jpackage-$jppcompat-compat\n");
	$main_sec->unshift_body("BuildRequires: /proc\n");
    }

    # maven hack
    $main_sec->subst_if(qr'\s+maven(\s|$)',' maven-plugins ', qr'^\s*BuildRequires:\s*');
    $main_sec->subst_if(qr'\s+maven2(\s|$)',' maven2-plugins ', qr'^\s*BuildRequires:\s*');


    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	#print "type is $t\n";
	if ($t eq 'package') {
	    &jpp_specific_cleanup_headers($sec);
	    $sec->subst(
		qr'\%define gcj_support \%{\?_with_gcj_support:1}\%{!\?_with_gcj_support:\%{\?_without_gcj_support:0}\%{!\?_without_gcj_support:\%{\?_gcj_support:\%{_gcj_support}}\%{!\?_gcj_support:0}}}', '%define gcj_support 0');
	    $sec->subst(qr'\%define\s+gcj_support\s+1', '%define gcj_support 0');
	    $sec->subst(qr'\%define\s+_with_gcj_support\s+1', '%define _with_gcj_support 0');

	} elsif ($t eq 'files') {
	    &jpp_specific_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	} elsif ($t eq 'post') {
	} elsif ($t eq 'postun') {
	} elsif ($t eq 'changelog') {
	}
	# general hacks here
	# is it worth wrapping in one?
	$sec->subst(qr'%{_localstatedir}/', '%{_var}/');
	# altlinux vs redhat incompatibility (found in hsqldb)
	#$sec->subst(qr'%{_localstatedir}/lib', '%{_var}/lib');
	#$sec->subst(qr'%{_localstatedir}/log', '%{_var}/log');# jetty 5
	#$sec->subst(qr'%{_localstatedir}/run', '%{_var}/run');# jetty 5
	#$sec->subst(qr'%{_localstatedir}/cache', '%{_var}/cache');# jetty 5
	# due to feature of alt findreq
	$sec->subst(qr'%{_sysconfdir}/init.d','%_initdir');
    }

    # hack... it looks like it should be moved to RPM::Source::Editor
    # zip -> bz2 due to alt buggy rpm (/usr/bin/unzip -qL) :(
    $main_sec=$rpm->get_section('package','');
    if ($main_sec->match(qr'^\s*Source\d*:.+\.(zip|jar)\s*$') 
	) {
        # source0 only!! others should be not %setup'ed, or we need explicit check
	#for (my $i=0;$i<@{$rpm->{SOURCES}}; $i++) {
	for (my $i=0;$i<1; $i++) {
	    my $source=$rpm->{SOURCES}->[$i];
	    $source=~s/\s*$//;
	    if ($source=~/\.(zip|jar)$/ and ! $rpm->get_section('prep')->match(qr'unzip -q %{SOURCE'.$i.'\}') and ! $rpm->is_specfile_mode()) {
		print STDERR "note: try to bzip2 zip source [$source]\n";
		my $sourcefile=$rpm->{SOURCEDIR}."/".basename($source);
		if (! -e $sourcefile) {
		    warn "Internal error: source $source not found!";
		} else {
		    my $convertdir= $rpm->{TMPDIR}.'/CONVERT'.$i;
		    mkdir $convertdir;
		    &RPM::Source::Editor::run ("pushd $convertdir; unzip -q $sourcefile; popd");
		    my @files= map {s,^\Q$convertdir\E/,,; $_} glob ("$convertdir/*");
		    my @hidden_files=grep {!/\.$/ && ! /\*$/} map {s,^\Q$convertdir\E/,,; $_} glob ("$convertdir/.*");
		    my $arjsuff='.bz2';
		    my $arjtarg='j';
		    if ($rpm->{NOBZ2}) {
			$arjtarg='';
			$arjsuff='';
		    }
		    $sourcefile=~s/\.(zip|jar)$/.tar$arjsuff/;
		    &RPM::Source::Editor::run ("tar c${arjtarg}f $sourcefile -C $convertdir @files @hidden_files");
		    my $rawsource=$rpm->{RAWSOURCES}->[$i];
		    my $newsource=$rawsource;
		    $newsource=~s/\.(zip|jar)$/.tar$arjsuff/;
		    $main_sec->subst(qr"$rawsource",$newsource);
		}
	    }
	}
    }
}

sub jpp_specific_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^\s*\%ghost\s*((?:\%dir|\%doc)\s*)*\%{_javadocdir}/) {
	    # we will leave ghost there... a usual symlink will not upgrade from directory
#	    s,^\s*\%ghost\s*,,g;
	    push @out, $_;
#	} elsif (/^\s*\%ghost\s*\%dir\s*\%{_javadocdir}/) {
	    # throw away -- seems dangerous
#	} elsif (/^\s*\%ghost\s*%{_bindir}/) {
	} elsif (/^\s*\%ghost\s*\%{_javadir}/) {
	    # seems to be touch for alternatives. better to exclude.
	    s/^\s*\%ghost\s*/\%exclude /;
	    push @out, $_;
	} elsif (/^\s*\%ghost\s*/) {
	    # alternatives ?
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN { our %JPP_GROUP_MAP = (
"Editors", "Editors",
"Text Editors", "Editors",
"Development/Tools/IDE", "Editors",
"Utilities", "Utilities",
"Multimedia/Graphics", "Graphics", # batik
"Database", "Databases", # derby
"Applications/Databases", "Databases",
"Networking/Instant messaging", "Networking/Instant messaging", # jext ??? horrible :(
"Internet/Log Analysis", "Monitoring",
"System/Servers", "System/Servers",
"System/Libraries", "System/Libraries", # ht2html
"Text Editors/Integrated Development Environments (IDE)", "Editors",
" ", " ",
	    ); 
}

sub jpp_specific_cleanup_headers {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^Group:(\s*)(.+\S)\s*$/) {
	    #if ($2) eq "System/Libraries" and ht2html
	    if (
		$2 eq "Development/Build Tools"
		or $2 eq "Development/Code Generators"
		or $2 eq "Development/Compilers"
		or $2 eq "Development/Framework"
		or $2 eq "Development/Java"
		or $2 eq "Development/Languages" # ecj
		or $2 eq "Development/Libraries"
		or $2 eq "Development/Libraries/Application Frameworks"
		or $2 eq "Development/LIbraries/Java" # jgroups (bug!)
		or $2 eq "Development/Libraries/Java"
		or $2 eq "Development/libraries/java" # axis2 (bug!)
		or $2 eq "Development/Test/Java"
		or $2 eq "Development/Testing"
		or $2 eq "Development/Tools"
		or $2 eq "Internet/WWW/Dynamic Content" #tomcat
		or $2 eq "Internet/WWW/Servers" #jboss
		or $2 eq "Internet/WWW/Indexing/Search" # lucene
		or $2 eq "Applications/Internet" # apacheds
		or $2 eq "System/Logging" # log4j
		or $2 eq "System/Networking" # mina
		or $2 eq "System Environment/Applications" #tomcat
		or $2 eq "System Environment/Libraries"
		or $2 eq "Security/Cryptography"
		or $2 eq "Software Development/Quality Assurance"
		or $2 eq "Networking/Daemons" # jacarta-common-daemons
		or $2 eq "System/Boot"
		or $2 eq "Utilities" # jarjar
		or $2 eq "Text Processing/Markup/XML"
		or $2 eq "Text Processing/Markup/HTML"
		or $2 eq "Documentation" # jacorb
		or $2 eq "Development/Debuggers" # findbugs
) {
		push @out, "Group:${1}Development/Java\n";
	    } elsif ($JPP_GROUP_MAP{$2}) {
		push @out, "Group:${1}$JPP_GROUP_MAP{$2}\n";
	    } elsif ($2 eq "Development/Documentation") {
		push @out, $_;
	    } else {
		die "unknown conversion for Group: $2";
	    }
	} elsif (/^\s*\%define\s+section\s+free\s*$/) {
	    # throw away
	} elsif (/^\s*((?:BuildRequires|PreReq|BuildPreReq|BuildPrereqs|Requires|Conflicts)\s*(?:\(\w+\))?)\s*:\s*(.*\S)\s*$/) {
	    my $Tag=$1;
	    my $filtered = &jpp_filter_pkg_list($2);
	    push @out, "$Tag: $filtered\n" if ($filtered);
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN {
our %JPPDEPSKIP = map {$_ => 1} qw!
java-devel java
java-1.4.2-devel java-1.5.0-devel
jce jsse 
!;
# java-devel jce jsse ...  are hack around Conflicts: in jpackage-1.x-compat
#jce jsse 


our %JPPDEPSUBST = (
'crimson' => 'jakarta-crimson',
'maven-modello-plugin' => 'maven-plugin-modello',
'modello-maven-plugin' => 'maven-plugin-modello',
#'ant-xslp' => 'ant-optional',
);

}

sub jpp_filter_pkg_list {
    my @in = split /[\s,]+/, $_[0];
    my @out;
    while (@in) {
	$_ = shift @in;
	if ($JPPDEPSKIP{$_}) {
	    &read_version(\@in);
	    next;
	} elsif ($JPPDEPSUBST{$_}) {
	    push @out, $JPPDEPSUBST{$_};
	} else {
	    push @out, $_;
	}
    }
    return join(" ",@out)
}

sub read_version {
    my $ptr=shift;
    return if ($#{$ptr}<1);
    if ($ptr->[0] =~/^(?:<|>|=|!=|>=|<=)$/) {
	return (shift @$ptr, shift @$ptr);
    }
    return;
}

sub alt_generic_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    my $cleanroot_pattern='^\s*(rm|%{__rm}) -rf (\$RPM_BUILD_ROOT|\%rpm_build_root)\s*$';
    &alt_generic_check_ahead($secptr->[0]);
    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	if ($t eq 'package') {
	    $sec->exclude('^(Packager|Vendor|Distribution|Build[Rr]oot):');
	    &alt_generic_cleanup_headers($sec);
	} elsif ($t eq 'description') {
	    &alt_generic_fix_desc($sec);
	} elsif ($t eq 'files') {
	    &alt_generic_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	    $sec->exclude($cleanroot_pattern);
	} elsif ($t eq 'clean') {
	    $sec->exclude($cleanroot_pattern);
	    $sec->delete() if ($sec->is_empty());
	} elsif ($t eq 'changelog') {
	    $sec->empty();
	} elsif ($t eq 'post') {
	    &alt_generic_convert_alternatives($rpm,$sec);
	} elsif (($t eq 'postun') or ($t eq 'preun')) {
	    &alt_generic_convert_alternatives($rpm,$sec);
	}
    }
}

BEGIN { our %ALT_GROUP_MAP = (
"Text Editors", "Editors",
" ", " ",
	    ); 
}


sub alt_generic_cleanup_headers {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^Group:(\s*)(.+\S)\s*$/ && $ALT_GROUP_MAP{$2}) {
		push @out, "Group:${1}$ALT_GROUP_MAP{$2}\n";
	} elsif (/^\s*((?:BuildRequires|PreReq|BuildPreReq|BuildPrereqs|Requires|Conflicts)\s*(?:\(\w+\))?)\s*:\s*(.*\S)\s*$/) {
	    my $Tag=$1;
	    my $filtered = &alt_filter_pkg_list($2);
	    push @out, "$Tag: $filtered\n" if ($filtered);
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN {
our %ALTDEPSKIP = map {$_ => 1} qw!
%{__make}
/bin/rm /bin/ln
!;

our %ALTDEPSUBST = (
'%{_sbindir}/update-alternatives' => 'alternatives >= 0:0.2.0-alt0.12',
'/usr/sbin/update-alternatives' => 'alternatives >= 0:0.2.0-alt0.12',
'mono-core' => 'mono',
'mozilla-nspr-devel' => 'libnspr-devel',
'nspr-devel' => 'libnspr-devel',
'mesa-libGL-devel' => 'libmesa-devel',
'mesa-libGLU-devel' => 'libmesa-devel',
'cairo-devel' => 'libcairo-devel',
'cairo' => 'libcairo',
'gnome-vfs2-devel' => 'gnome-vfs-devel',
'gnome-vfs2' => 'gnome-vfs',
'apr-devel' => 'libapr1-devel',
'openssl-devel' => 'libssl-devel',
' ' => ' ',
);

}

sub alt_filter_pkg_list {
    $_=$_[0];
    # hack around add_changelog error
    #error: Dependency tokens must not contain '%<=>' symbols: Requires: icu4j-eclipse > = 3.6.1
    s/\>\s+=/>=/g;
    s/\<\s+=/<=/g;
    my @in = split /[\s,]+/, $_;
    my @out;
    while (@in) {
	$_ = shift @in;
	if ($ALTDEPSKIP{$_}) {
	    &read_version(\@in);
	    next;
	} elsif ($ALTDEPSUBST{$_}) {
	    push @out, $ALTDEPSUBST{$_};
	} else {
	    push @out, $_;
	}
    }
    return join(" ",@out);
};


# is macro %name used in spec before Name:,Version: tags
# it is not allowed in alt
sub alt_generic_check_ahead {
    my $section=shift;
    my @out;
    my $is_name_passed=0;
    my $is_name_ahead=0;
    foreach (@{$section->get_body()}) {
	m/^\s*Name:/ and $is_name_passed=1; #and print STDERR "passed $_\n";
	$is_name_ahead=1 if m/\%\{name\}/ and $is_name_passed==0;
#print STDERR "AHEAD $_\n";
	$is_name_ahead=1 if m/\%name(?:[^\w\d_]|$)/ and $is_name_passed==0;
#print STDERR "ahead $_\n";
    }
    if ($is_name_ahead) {
	$section->unshift_body('%define name '.$jpp->get_section('package','')->get_tag('Name')."\n");
	$section->unshift_body('%define version '.$jpp->get_section('package','')->get_tag('Version')."\n");
	print STDERR "fixed ahead!!!\n";
    }
}

sub alt_generic_fix_desc {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
# some distro use iso in description. alt use ascii only.
	    #tr/é/e/;
	    tr/éöóêåíãøùçõúôûâàïðîëäæýÿñìèòüáþÉÖÓÊÅÍÃØÙÇÕÚÔÛÂÀÏÐÎËÄÆÝßÑÌÈÒÜÁÞ/eooeaiaoucououaaidieaayvnieouabEOOEAIAOUCOUOUAAIDIEAAYVNIEOUAB/;
	    # % in description
	    s,%(\s|$),%% ,g;
	    push @out, $_;
    }
    $section->set_body(\@out);
}

sub alt_generic_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/^\s*\%attr\(-,root,root\)\s*//;
	#if (/^\s*\%defattr\(0644,root,root,0755\)\s*$/
	if (/^\s*\%defattr\((?:0644|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0664|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0644|-),root,root\)\s*$/
	    ) {
	    # throw away
	} elsif (/^\s*\%defattr\(0755,root,root,0755\)\s*$/) {
	    # dangerous: as in antlr may cause lost 755 rights in /usr/bin
	    push @out, "#".$_;
	} elsif (/^\s*\%doc\s*\%\{_docdir\}\s*$/) {
	    push @out, '%doc %{_docdir}/*'."\n";
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub alt_generic_convert_alternatives {
    my $rpm=shift;
    my $section=shift;
    my @out;
    my $ptr = $section->get_body();
    while (@$ptr>0) {
	my $line = shift @$ptr;
	if ($line!~/\s*#/ && $line=~s,^(\s*)(?:(?:\%{_sbindir}|/usr/sbin)/)?update-alternatives --(\w+),,) {
	    my $preline=$1;
	    my $updcmd=$2;
	    $line=&read_multiline($line, $ptr);
	    # the end is abandoned :(
	    if ($updcmd eq "remove") {
		my $name=&read_shell_token(\$line);
		push @out, $preline.'%unregister_alternatives '.&get_alternatives_file_name($rpm,$section,$name)."\n";
	    } elsif ($updcmd eq "install") {
		my $link=&read_shell_token(\$line);
		my $name=&read_shell_token(\$line);
		my $path=&read_shell_token(\$line);
		my $priority=&read_shell_token(\$line);
		my @alternatives=($link,$path,$priority);
		&read_space(\$line);
		while ($line=~/--slave/) {
		    &read_shell_token(\$line);
		    my $slink=&read_shell_token(\$line);
		    my $sname=&read_shell_token(\$line);
		    my $spath=&read_shell_token(\$line);
		    push @alternatives, ($slink,$spath,$path);
		}
		&create_alternatives($rpm,$section, &get_alternatives_file_name($rpm,$section,$name),\@alternatives);
		push @out, $preline.'%register_alternatives '.&get_alternatives_file_name($rpm,$section,$name)."\n";
	    } else {
		push @out, $preline."# unknown update-alternatives --$updcmd\n";
	    }
	} else {
	    push @out, $line;
	}
    }
    $section->set_body(\@out);
}

sub create_alternatives {
    my ($rpm, $section, $alternatives_file_name,$alternativesptr) = @_;
    my @text=('install -d $RPM_BUILD_ROOT/%_altdir; cat >$RPM_BUILD_ROOT/%_altdir/'.$alternatives_file_name.'<<EOF
');
    while (@$alternativesptr>0) {
	my $provided=shift(@$alternativesptr);
	my $alternative=shift(@$alternativesptr);
	my $weight=shift(@$alternativesptr);
	push @text, $provided."\t".$alternative."\t".$weight."\n";
    }
    push @text, "EOF\n";
    $rpm->get_section('install')->push_body(@text);
    $rpm->get_section('files',$section->get_package())->unshift_body('%_altdir/'.$alternatives_file_name."\n");
}

sub get_alternatives_file_name {
    my ($rpm,$section,$name)=@_;
    return $name.'_'.$section->get_package_expanded();
}

sub read_multiline {
    my ($line, $ptr) =@_;
    while (@$ptr>0 && $line=~s/\\[\r\n]+?$//) {
	chomp $line;
#	print "MULTILINE:$line\n";
	$line.=shift(@$ptr);
    }
    return $line;
}

sub read_shell_token {
    my ($lineptr) =@_;
    if ($$lineptr=~s/^\s*(\S+)//) {
	return $1;
    }
    return "";
}

sub read_space {
    my ($lineptr) =@_;
    $$lineptr=~s/^\s*//;
}

1;

#!/usr/bin/perl -w

#use strict;
use warnings;
use Carp;
use Getopt::Long;
use File::Basename;
use RPM qw/vercmp/;
use RPM::Source::Editor;
use RPM::Source::Convert::Generic2ALT;
use RPM::Source::Convert::JPackage2ALT;
use RPM::Source::Convert::MergeALT;

my ($jpprpm,$altrpm,$jppspec,$altspec,$hook,$changelog,$release,$epoch,$rename,$nobz2,$nozip);
my $jvm=5;
my $packager='auto';
my $verbose=1;
my $cleanup=0;
my $outputdir='.';
my $patchdir=dirname($0)."/patches";

my $result = GetOptions ("jpp=s" => \$jpprpm,
		      "alt=s"   => \$altrpm,
		      "jvm=s" => \$jvm,
		      "jppspec=s" => \$jppspec,
		      "altspec=s"   => \$altspec,
		      "outdir=s"   => \$outputdir,
		      "packager=s"   => \$packager,
		      "hook=s"   => \$hook,
		      "changelog=s"   => \$changelog,
		      "rename=s"   => \$rename,
		      "cleanup!"   => \$cleanup,
		      "release=s"   => \$release,
		      "epoch=s"   => \$epoch,
		      "nobz2"   => \$nobz2,
		      "nozip"   => \$nozip,
		      "verbose+"  => \$verbose);
my ($alt,$jpp);

if (! $jpprpm && ! $jppspec) {
    print "ERROR: one of --jpp | --jppspec is required!\n";
    print "options:
--jpp /path/to/jpackage.src.rpm
--alt /path/to/altlinux.src.rpm
--jppspec /path/to/jpackage.spec
--altspec /path/to/altlinux.spec
--hook /path/to/hook to be called on resulting spec file
--jvm jvm JVM required for the build. by default, it is java-1.4.2.
  values are: 4 5 6 4.2 5.0 6.0
--out /path/to/output_dir
--changelog '- message'
--release 'release' - if we need to adjust the package's release

usage examples:
* convert srpm:
jppimport --alt Sisyphus/antlr-2.7.6-alt1.src.rpm --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm
* convert srpm without history:
jppimport --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm --srpmdir ~/OUT
* convert spec:
jppimport --altspec antlr.spec --jppspec jpackage/1.7/generic/free/SPECS/antlr.spec
";
    exit (64);
}

$jpp=RPM::Source::Editor->new(
    SOURCERPM => $jpprpm, 
    SPECFILE=> $jppspec, 
    OUTPUTDIR=> $outputdir, 
    PATCHDIR=>$patchdir, 
    VERBOSE=> $verbose,
    CLEANUP=> $cleanup,
    CHANGELOG=>'- converted from JPackage by jppimport script',
    CONVERT::JPACKAGE::JVM=>$jvm,
    CONVERT::JPACKAGE::NOBZ2=>$nobz2, 
    CONVERT::JPACKAGE::NOZIP=>$nozip, 
);

my $jppepoch = $jpp->get_section('package','')->get_tag('Epoch');
my $jpprel = $jpp->get_section('package','')->get_tag('Release');
my $jppver = $jpp->get_section('package','')->get_tag('Version');
# $jppsubrel is used to keep branch of fedora or mandriva
my $jppsubrel='';
# for new jpackage 5.0
$jpprel=~s/\%\{dist\}//;
# for fedora-based imports (hack :()
if ($jpprel=~/\%\{\?dist\}/) {
    $jpprel=~s/\%\{\?dist\}//;
    $jpprel=~s/jpp(\.\d+)?//;
    $jppsubrel=$1 if $1;
}
$jpprel=~s/jpp\d.\d$//;
$jpprel=~s/.jpp5$//;
$jpprel=~s/jpp//;

my $newjava='5';
if ($jvm and $jvm =~ /^4/) {
    $newjava = '1.7';
} elsif ($jvm and $jvm =~ /^5/) {
    $newjava = '5';
} elsif ($jvm and $jvm =~ /^6/) {
    $newjava = '6';
}

my $altepoch;
my $altrel="alt1";
if ($altrpm || $altspec) {
    $alt=RPM::Source::Editor->new(SOURCERPM => $altrpm, SPECFILE => $altspec, VERBOSE=> $verbose);
    $altepoch = $alt->get_section('package','')->get_tag('Epoch');
    $altrel = $alt->get_section('package','')->get_tag('Release');
    $altver = $alt->get_section('package','')->get_tag('Version');
    my $vercmp = `rpmvercmp $altver $jppver`;
    chomp $vercmp;
    if ($altrel=~/^alt([^_]+)_(.+)jpp(\d(?:\.\d)?)$/) {
	my $rel = $1;
	my $jppfrom = $2;
	my $java= $3;
	my $subrel='';
	$subrel=$1 if ($rel=~s/(\.\d+)$//);
	# hack -- cleanup (undefined in jpp) macro in alt release:
	$rel=~s/.?\%\w+//g;
	$rel=~s/.?\%\{\w+\}+//g;
	print STDERR "new alt release: jpprel=$jpprel rel=$rel subrel=$subrel jppfrom=$jppfrom jppsubrel=$jppsubrel $java\n" if $verbose>1;
	if ($rel=~/^0\./ or $vercmp != 0) {
	    print STDERR "set rel=1\n" if $verbose>1;
	    $rel=1;
	} elsif (($jppfrom eq $jpprel) and $subrel and $jppsubrel and $subrel < $jppsubrel) {
	    # nothing to do
	    print STDERR "nothing to do: new subrel is higher\n" if $verbose>1;
	} elsif (not $subrel and &vercmp(0,$jpprel,0,$jppfrom) >0) {
	    # nothing to do
	    print STDERR "nothing to do: new jppfrom is higher\n" if $verbose>1;
	} elsif (($jppfrom eq $jpprel) and not $subrel and $java and ($java < $newjava)) {
	    # nothing to do
	    print STDERR "nothing to do: new java is higher\n" if $verbose>1;
	} else {
	    $rel=~/^(\d+)/;
	    $rel=$1+1;
	    print STDERR "++rel=$rel\n" if $verbose>1;
	}
	$altrel='alt'.$rel;
    } else {
	print STDERR "first alt release $altrel\n" if $verbose>1;
	$altrel=~s/.?\%\w+//g;
	$altrel=~s/.?\%\{\w+\}+//g;
	$altrel='alt1' if $altrel=~/^alt0\./ or $vercmp != 0;
    }
    if ($packager eq 'auto') {
	my $altpackager=$alt->get_section('package','')->get_tag('Packager');
	$packager=$altpackager if $altpackager;
    }

    print STDERR "entering alt_generic_merge\n" if $verbose>1;
    &RPM::Source::Convert::MergeALT::alt_generic_merge($jpp,$alt);
    print STDERR "done alt_generic_merge\n" if $verbose>1;

    $alt->cleanup();

    unless ($epoch) {
	if (defined $altepoch) {
	    $epoch=$altepoch if ! defined $jppepoch || $altepoch > $jppepoch;
	}
    }
}



# our -- hack ?
our $jpptoolsdir=dirname($0);
# for cross-references in hooks
push @INC, $jpptoolsdir."/hooks", $jpptoolsdir."/common";

if (not $hook) {
    # looking for default hook
    my $name = $jpp->get_section('package','')->get_tag('Name');
    $name=$rename if $rename;
    my $defhook="$jpptoolsdir/hooks/$name.pl";
    # macro_expansion should be here
    #print "looking for default hook $defhook\n";
    $hook = $defhook if (-e $defhook);
}

our @SPECHOOKS;
our @PREHOOKS;
if ($hook) {
    require $hook;
    die "script $hook does not have a valid hook!\n" unless @PREHOOKS or @SPECHOOKS;
    if (@PREHOOKS) {
	$jpp->{WARN_NOTAPPLIED}++;
	map {&$_($jpp,$alt)} @PREHOOKS;
	$jpp->{WARN_NOTAPPLIED}--;
    }
}

$jpp->rename_package($rename) if $rename;

#map {print STDERR $_->describe(1)} $jpp->get_sections();
print STDERR "entering alt_generic_fixes\n" if $verbose>1;
&RPM::Source::Convert::Generic2ALT::alt_generic_fix($jpp);
print STDERR "done alt_generic_fixes\n" if $verbose>1;
#map {print STDERR $_->describe(1)} $jpp->get_sections();
&RPM::Source::Convert::JPackage2ALT::jpp_specific_fix($jpp);
print STDERR "done jpp_specific_fixes\n" if $verbose>1;
#map {print STDERR $_->describe(1)} $jpp->get_sections();


my $newrel = $altrel.$jppsubrel."_".$jpprel.'jpp'.$newjava;
$newrel=$release if ($release);
$jpp->get_section('package','')->set_tag('Release',$newrel);

if ($hook) {
    if (@SPECHOOKS) {
	$jpp->{WARN_NOTAPPLIED}++;
	map {&$_($jpp,$alt)} @SPECHOOKS;
	$jpp->{WARN_NOTAPPLIED}--;
    }
}

if ($altrpm || $altspec) {
    $jpp->get_section('changelog')->set_body($alt->get_section('changelog')->get_body());
}

if ($changelog) {
    $jpp->set_changelog($changelog);
}

if ($packager eq 'auto') {
    $packager=$jpp->macros()->macro_subst('%{packager}');
}

if ($packager) {
    if ($packager ne 'none') {
	$jpp->get_section('package','')->set_tag('Packager',$packager);
    } else {
	$jpp->get_section('package','')->clear_tag('Packager');
    }
}

if (defined $epoch) {
    $jpp->get_section('package','')->set_tag('Epoch',$epoch);
}

print $jpp->get_spec() if $jppspec or $verbose>3;
$jpp->write_rpm() if $jpprpm;
$jpp->cleanup();


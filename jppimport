#!/usr/bin/perl -w

#use strict;
use warnings;
use Carp;
use Getopt::Long;

my ($jpprpm,$altrpm,$jppspec,$altspec,$hook,$changelog);
my $verbose;
my $srpmdir='.';
my $result = GetOptions ("jpp=s" => \$jpprpm,
		      "alt=s"   => \$altrpm,
		      "jppspec=s" => \$jppspec,
		      "altspec=s"   => \$altspec,
		      "srpmdir=s"   => \$srpmdir,
		      "out=s"   => \$srpmdir,
		      "hook=s"   => \$hook,
		      "changelog=s"   => \$changelog,
		      "verbose"  => \$verbose);
my ($alt,$jpp);

if (! $jpprpm && ! $jppspec) {
    print "ERROR: one of --jpp | --jppspec is required!\n";
    print "options:
--jpp /path/to/jpackage.src.rpm
--alt /path/to/altlinux.src.rpm
--jppspec /path/to/jpackage.spec
--altspec /path/to/altlinux.spec
--hook /path/to/hook to be called on resulting spec file
--srpmdir /path/to/output_dir
--out  is the same as --srpmdir
--changelog '- message'

usage examples:
* convert srpm:
jppimport --alt Sisyphus/antlr-2.7.6-alt1.src.rpm --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm
* convert srpm without history:
jppimport --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm --srpmdir ~/OUT
* convert spec:
jppimport --altspec antlr.spec --jppspec jpackage/1.7/generic/free/SPECS/antlr.spec
";
    exit (64);
}

$jpp=RPM::ImportTool->new(RPM => $jpprpm, SPECFILE=> $jppspec, SRPMDIR=> $srpmdir);

&alt_generic_fix($jpp);
&jpp_specific_fix($jpp);

my $altrel="alt1";
my $jpprel = $jpp->get_section('package','')->get_tag('Release');
if ($altrpm || $altspec) {
    $alt=RPM::ImportTool->new(RPM => $altrpm, SPECFILE => $altspec);
    $altrel = $alt->get_section('package','')->get_tag('Release');
    $jpp->get_section('changelog')->set_body($alt->get_section('changelog')->get_body());
    # hack -- cleanup (undefined in jpp) macro in alt release:
    if ($altrel=~/^alt([^_]+)_(.+jpp)(\d.\d)$/) {
	my $rel = $1;
	$rel=~s/.?\%\w+//g;
	$rel=~s/.?\%\{\w+\}+//g;
	$rel='1' if $rel=~/^0\./;
	$rel=$rel+1 if ($2 eq $jpprel);
	$altrel='alt'.$rel;
    } else {
	$altrel=~s/.?\%\w+//g;
	$altrel=~s/.?\%\{\w+\}+//g;
	$altrel='alt1' if $altrel=~/^alt0\./;
    }
    $alt->cleanup();
}
my $newrel = $altrel."_".$jpprel."1.7";
$jpp->get_section('package','')->set_tag('Release',$newrel);

# our -- hack ?
our $jpptoolsdir=&RPM::ImportTool::dirname($0);
# for cross-references in hooks
push @INC, $jpptoolsdir."/hooks";

if (not $hook) {
    # looking for default hook
    my $name = $jpp->get_section('package','')->get_tag('Name');
    my $defhook="$jpptoolsdir/hooks/$name.pl";
    # macro_expansion should be here
    #print "looking for default hook $defhook\n";
    $hook = $defhook if (-e $defhook);
}
if ($hook) {
    our $spechook;
    require $hook;
    if ($spechook) {
	&$spechook($jpp,$alt);
    } else {
	die "script $hook does not have a valid hook!\n";
    }
}

if ($changelog) {
    $jpp->set_changelog($changelog);
}

print $jpp->get_spec() if $jppspec or $verbose;
$jpp->write_rpm() if $jpprpm;
$jpp->cleanup();

my $TODO=qq~
%if %{native} %if ! %{gcj_support}
BuildRequires:  %{_bindir}/gcj, %{__perl}, 
~;


sub jpp_specific_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    if (not $secptr->[0]->match(qr'BuildRequires: jpackage-1.4-compat')) {
	$secptr->[0]->unshift_body("BuildRequires: jpackage-1.4-compat\n");
	$secptr->[0]->unshift_body("BuildRequires: /proc\n");
    }
    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	if ($t eq 'package') {
	    &jpp_specific_cleanup_headers($sec);
	    $sec->subst(
		qr'\%define gcj_support \%{\?_with_gcj_support:1}\%{!\?_with_gcj_support:\%{\?_without_gcj_support:0}\%{!\?_without_gcj_support:\%{\?_gcj_support:\%{_gcj_support}}\%{!\?_gcj_support:0}}}', '%define gcj_support 0');
	} elsif ($t eq 'files') {
	    &jpp_specific_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	} elsif ($t eq 'post') {
	} elsif ($t eq 'postun') {
	} elsif ($t eq 'changelog') {
	}
    }

    # hack... it looks like it should be moved to RPM::ImportTool
    # zip -> bz2 due to alt buggy rpm (/usr/bin/unzip -qL) :(
    $main_sec=$jpp->get_section('package','');
    if ($main_sec->match(qr'^\s*Source\d*:.+.zip\s*$')) {
	for (my $i=0;$i<@{$rpm->{SOURCES}}; $i++) {
	    my $source=$rpm->{SOURCES}->[$i];
	    if ($source=~/\.zip$/) {
		my $sourcefile=$rpm->{SOURCEDIR}."/".&RPM::ImportTool::basename($source);
		if (! -e $sourcefile) {
		    warn "Internal error: source $source not found!";
		} else {
		    my $convertdir= $rpm->{TMPDIR}.'/CONVERT'.$i;
		    mkdir $convertdir;
		    &RPM::ImportTool::run ("pushd $convertdir; unzip -q $sourcefile; popd");
		    my @files= map {s,^\Q$convertdir\E/,,; $_} glob ("$convertdir/*");
		    my @hidden_files=grep {!/\.$/ && ! /\*$/} map {s,^\Q$convertdir\E/,,; $_} glob ("$convertdir/.*");
		    $sourcefile=~s/\.zip$/.tar.bz2/;
		    &RPM::ImportTool::run ("tar cjf $sourcefile -C $convertdir @files @hidden_files");
		    my $source2=$source;
		    $source2=~s/\.zip$/.tar.bz2/;
		    $main_sec->subst(qr"$source",$source2);
		}
	    }
	}
    }
}

sub jpp_specific_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^\s*\%ghost\s*((?:\%dir|\%doc)\s*)*\%{_javadocdir}/) {
	    # we will leave ghost there... a usual symlink will not upgrade from directory
#	    s,^\s*\%ghost\s*,,g;
	    push @out, $_;
#	} elsif (/^\s*\%ghost\s*\%dir\s*\%{_javadocdir}/) {
	    # throw away -- seems dangerous
#	} elsif (/^\s*\%ghost\s*%{_bindir}/) {
	} elsif (/^\s*\%ghost\s*/) {
	    # alternatives ?
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN { our %JPP_GROUP_MAP = (
"Text Editors", "Editors",
"Utilities", "Utilities",
"Multimedia/Graphics", "Graphics", # batik
"Database", "Databases", # derby
"Applications/Databases", "Databases",
"Networking/Instant messaging", "Networking/Instant messaging", # jext ??? horrible :(
"Internet/Log Analysis", "Monitoring",
"System/Servers", "System/Servers",
" ", " ",
	    ); 
}

sub jpp_specific_cleanup_headers {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^Group:(\s*)(.+)\s*$/) {
	    #if ($2) eq "System/Libraries" and ht2html
	    if (
		$2 eq "Development/Build Tools"
		or $2 eq "Development/Code Generators"
		or $2 eq "Development/Compilers"
		or $2 eq "Development/Framework"
		or $2 eq "Development/Java"
		or $2 eq "Development/Languages" # ecj
		or $2 eq "Development/Libraries"
		or $2 eq "Development/Libraries/Application Frameworks"
		or $2 eq "Development/LIbraries/Java" # jgroups (bug!)
		or $2 eq "Development/Libraries/Java"
		or $2 eq "Development/Test/Java"
		or $2 eq "Development/Testing"
		or $2 eq "Development/Tools"
		or $2 eq "Internet/WWW/Dynamic Content" #tomcat
		or $2 eq "Internet/WWW/Servers" #jboss
		or $2 eq "Internet/WWW/Indexing/Search" # lucene
		or $2 eq "Applications/Internet" # apacheds
		or $2 eq "System/Logging" # log4j
		or $2 eq "System/Networking" # mina
		or $2 eq "System Environment/Applications" #tomcat
		or $2 eq "System Environment/Libraries"
		or $2 eq "Security/Cryptography"
		or $2 eq "Software Development/Quality Assurance"
		or $2 eq "Networking/Daemons" # jacarta-common-daemons
		or $2 eq "System/Boot"
		or $2 eq "Text Processing/Markup/XML"
		or $2 eq "Text Processing/Markup/HTML"
		or $2 eq "Documentation" # jacorb
) {
		push @out, "Group:${1}Development/Java\n";
	    } elsif ($JPP_GROUP_MAP{$2}) {
		push @out, "Group:${1}$JPP_GROUP_MAP{$2}\n";
	    } elsif ($2 eq "Development/Documentation") {
		push @out, $_;
	    } else {
		die "unknown conversion for Group: $2";
	    }
	} elsif (/^\s*\%define\s+section\s+free\s*$/) {
	    # throw away
	} elsif (/^\s*((?:BuildRequires|PreReq|BuildPreReq|BuildPrereqs|Requires|Conflicts)(?:\(\w+\))?):\s*(.+)\s*$/) {
	    my $Tag=$1;
	    my $filtered = &filter_pkg_list($2);
	    push @out, "$Tag: $filtered\n" if ($filtered);
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN {
our %DEPSKIP = map {$_ => 1} qw!
%{__make}
/bin/rm /bin/ln
java-javadoc
!;
our %DEPSUBST = (
'%{_sbindir}/update-alternatives', 'alternatives >= 0:0.2.0-alt0.12',
'/usr/sbin/update-alternatives', 'alternatives >= 0:0.2.0-alt0.12',
'mono-core','mono',
);

}

sub filter_pkg_list {
    my @in = split /[\s,]+/, $_[0];
    my @out;
    while (@in) {
	$_ = shift @in;
	if ($DEPSKIP{$_}) {
	    &read_version(\@in);
	    next;
	} elsif ($DEPSUBST{$_}) {
	    push @out, $DEPSUBST{$_};
	} else {
	    push @out, $_;
	}
    }
    return join(" ",@out)
}

sub read_version {
    my $ptr=shift;
    return if ($#{$ptr}<1);
    if ($ptr->[0] =~/^(?:<|>|=|!=|>=|<=)$/) {
	return (shift @$ptr, shift @$ptr);
    }
    return;
}

sub alt_generic_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    my $cleanroot_pattern='^\s*rm -rf (\$RPM_BUILD_ROOT|\%rpm_build_root)\s*$';
    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	if ($t eq 'package') {
	    $sec->exclude('^(Packager|Vendor|Distribution|BuildRoot):');
	} elsif ($t eq 'files') {
	    &alt_generic_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	    $sec->exclude($cleanroot_pattern);
	} elsif ($t eq 'clean') {
	    $sec->exclude($cleanroot_pattern);
	    $sec->delete() if ($sec->is_empty());
	} elsif ($t eq 'changelog') {
	    $sec->empty();
	} elsif ($t eq 'post') {
	    &alt_generic_convert_alternatives($rpm,$sec);
	} elsif (($t eq 'postun') or ($t eq 'preun')) {
	    &alt_generic_convert_alternatives($rpm,$sec);
	}
    }
}

sub alt_generic_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/^\s*\%attr\(-,root,root\)\s*//;
	#if (/^\s*\%defattr\(0644,root,root,0755\)\s*$/
	if (/^\s*\%defattr\((?:0644|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0664|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0644|-),root,root\)\s*$/
	    ) {
	    # throw away
	} elsif (/^\s*\%defattr\(0755,root,root,0755\)\s*$/) {
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub alt_generic_convert_alternatives {
    my $rpm=shift;
    my $section=shift;
    my @out;
    my $ptr = $section->get_body();
    while (@$ptr>0) {
	my $line = shift @$ptr;
	if ($line!~/\s*#/ && $line=~s,^(\s*)(?:(?:\%{_sbindir}|/usr/sbin)/)?update-alternatives --(\w+),,) {
	    my $preline=$1;
	    my $updcmd=$2;
	    $line=&read_multiline($line, $ptr);
	    # the end is abandoned :(
	    if ($updcmd eq "remove") {
		my $name=&read_shell_token(\$line);
		push @out, $preline.'%unregister_alternatives '.&get_alternatives_file_name($rpm,$section,$name)."\n";
	    } elsif ($updcmd eq "install") {
		my $link=&read_shell_token(\$line);
		my $name=&read_shell_token(\$line);
		my $path=&read_shell_token(\$line);
		my $priority=&read_shell_token(\$line);
		my @alternatives=($link,$path,$priority);
		&read_space(\$line);
		while ($line=~/--slave/) {
		    &read_shell_token(\$line);
		    my $slink=&read_shell_token(\$line);
		    my $sname=&read_shell_token(\$line);
		    my $spath=&read_shell_token(\$line);
		    push @alternatives, ($spath,$slink,$path);
		}
		&create_alternatives($rpm,$section, &get_alternatives_file_name($rpm,$section,$name),\@alternatives);
		push @out, $preline.'%register_alternatives '.&get_alternatives_file_name($rpm,$section,$name)."\n";
	    } else {
		push @out, $preline."# unknown update-alternatives --$updcmd\n";
	    }
	} else {
	    push @out, $line;
	}
    }
    $section->set_body(\@out);
}

sub create_alternatives {
    my ($rpm, $section, $alternatives_file_name,$alternativesptr) = @_;
    my @text=('install -d $RPM_BUILD_ROOT/%_altdir; cat >$RPM_BUILD_ROOT/%_altdir/'.$alternatives_file_name.'<<EOF
');
    while (@$alternativesptr>0) {
	my $provided=shift(@$alternativesptr);
	my $alternative=shift(@$alternativesptr);
	my $weight=shift(@$alternativesptr);
	push @text, $provided."\t".$alternative."\t".$weight."\n";
    }
    push @text, "EOF\n";
    $rpm->get_section('install')->push_body(@text);
    $rpm->get_section('files',$section->get_package())->unshift_body('%_altdir/'.$alternatives_file_name."\n");
}

sub get_alternatives_file_name {
    my ($rpm,$section,$name)=@_;
    return $name.'_'.$section->get_package_expanded();
}

sub read_multiline {
    my ($line, $ptr) =@_;
    while (@$ptr>0 && $line=~s/\\[\r\n]+?$//) {
	chomp $line;
#	print "MULTILINE:$line\n";
	$line.=shift(@$ptr);
    }
    return $line;
}

sub read_shell_token {
    my ($lineptr) =@_;
    if ($$lineptr=~s/^\s*(\S+)//) {
	return $1;
    }
    return "";
}

sub read_space {
    my ($lineptr) =@_;
    $$lineptr=~s/^\s*//;
}

package RPM::SpecSection;

sub new {
    my $class = shift;
    my $self= {
	TYPE=> 'package',
	PACKAGE=> '',
	BODY=>[],
	@_
    };
    my $TYPE='package';
    my $PACKAGE='';
    if ($self->{BODY}->[0]=~/^\s*\%(\w+)(?:\s+(\S+))?\s*$/ && $RPM::ImportTool::SECTION{$1}) {
	$TYPE=$1;
	$PACKAGE=$2;
	$self->{TYPE}=$TYPE;
	$self->{PACKAGE}=$PACKAGE;
    }
    $self->{PACKAGE}='' unless defined $self->{PACKAGE};
    die "Oops! section" if ref $self->{BODY} ne 'ARRAY';
    bless $self, $class;
#    return $self;
}

sub describe {
    my $self=shift;
    print "SpecSection: type=$self->{TYPE}; package=$self->{PACKAGE}; body: ==>\n".join('',@{$self->{BODY}}),"============== END BODY ====================\n";
}

sub get_type {
    my $self=shift;
    return $self->{TYPE};
}

sub get_package {
    my $self=shift;
    return $self->{PACKAGE};
}

sub get_package_expanded {
    my $self=shift;
    my $pkg= $self->{PACKAGE};
    return '%{name}' unless $pkg;
    return $pkg if $pkg=~s/-n\s*//;
    return '%{name}-'.$pkg; 
}

sub get_body {
    my $self=shift;
    return $self->{BODY};
}

sub set_body {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ref $ptr ne 'ARRAY';
    $self->{BODY}=$ptr;
}

sub unshift_body {
    my $self=shift;
    if ($self->is_head_section()) {
	unshift @{$self->{BODY}}, @_;
    } else {
	my $head = shift @{$self->{BODY}};
	unshift @{$self->{BODY}}, $head, @_;
    }
}

sub push_body {
    my $self=shift;
    my $bodyptr=$self->{BODY};
    # move pushed item(s) before %if* block of next section
    my @tail;
    my $i=$#{$bodyptr};
    while ($i>=0 and $bodyptr->[$i]=~/^\s*\%if/) {
	unshift @tail, pop @{$bodyptr};
	$i--;
    }
    push @{$bodyptr}, @_, @tail;
}

sub empty {
    my $self=shift;
    $#{$self->{BODY}}=0 if ($#{$self->{BODY}}>0);
}

sub delete {
    my $self=shift;
    $self->{BODY}=[];
}

sub is_empty {
    my $self=shift;
    return 1 if $#{$self->{BODY}}<1;
    foreach (@{$self->{BODY}}[1..$#{$self->{BODY}}]){
	return 0 if ! /^\s*(#.*)?$/;
    }
    return 1;
}

sub is_head_section {
    my $self=shift;
    return 1 if $self->{TYPE} eq 'package' && $self->{PACKAGE} eq '';
    return 0;
}

sub exclude {
    my $section=shift;
    my $pattern=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	unless (/$pattern/) {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub subst {
    my $section=shift;
    my $pattern=shift;
    my $replace=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/$pattern/$replace/g;
	push @out, $_;
    }
    $section->set_body(\@out);
}

sub match {
    my $section=shift;
    my $pattern=shift;
    foreach (@{$section->get_body()}) {
	return 1 if /$pattern/;
    }
    return 0;
}

sub get_tag {
    my $section=shift;
    my $tag=shift;
    my %options = (
	RAW=>0,
	@_);
    foreach (@{$section->get_body()}) {
	if (/^$tag:\s*(.+)\s*$/) {
	    my $val=$1;
	    if (!$options{RAW}) {
		&RPM::ImportTool::macro_subst($section->{RPM}->{MACRO},\$val);
	    }
	    return $val;
	}
    }
    return;
}

sub set_tag {
    my ($section, $tag, $val)=@_;
    my $specptr=$section->get_body();
    for (my $i=0; $i<=$#{$specptr}; $i++) {
	if ($specptr->[$i]=~/^$tag:(\s*)/) {
	    $specptr->[$i]="$tag:$1$val\n";
	    last;
	}
    }
    return $section;
}


package RPM::ImportTool;

sub new {
    my $class = shift;
    my $self = {
	CHANGELOG=>'- converted from JPackage by jppimport script',
	@_
    };
    bless $self, $class;
    if ($self->{RPM}) {
	if ($self->{RPM}!~/.src.rpm$/ && `file $self->{RPM}`!~/RPM/) {
	    die "$self->{RPM}: not a rpm file!\n";
	}
	my $dirname=&basename($self->{RPM});
	$dirname=~s/.src.rpm//;
	my $pwd= `pwd`;
	chomp $pwd;
	$self->{TMPDIR}||="$pwd/$dirname.$$";
	$self->{SOURCEDIR}||="$self->{TMPDIR}/SOURCES";
	$self->{SPECDIR}||="$self->{TMPDIR}/SPECS";
	$self->{SRPMDIR}||="$self->{TMPDIR}/SRPMS";
	$self->rpm_custom("-i", $self->{RPM});
	$self->{SPECFILE}=(glob "$self->{TMPDIR}/SPECS/*")[0];
    } elsif ($self->{SPECFILE}) {
    } else {
	die "$class: new: either RPM or SPECFILE is required."
    }
    $self->_set_speclist(load_file($self->{SPECFILE}));
    $self->load_macro();
    return $self;
}

sub write_rpm {
    my $self=shift;
    my $newdir="$self->{TMPDIR}/NEW";
    mkdir $newdir;
    my $newspec="$newdir/".basename($self->{SPECFILE});
    &write_file($newspec, $self->get_spec());
    run("add_changelog -e '$self->{CHANGELOG}' $newspec");
    $self->rpm_custom('-bs --nodeps', $newspec);
}

BEGIN {
    our %SECTION=map {$_=>1} qw!
package
description
prep
build
install
clean
files
changelog
pre
post
preun
postun
triggerin
triggerun
triggerpostun
!
}

sub _parse_speclist {
    my $rpm=shift;
    my $specptr=shift;
    my @outpart;
    my $out=[];
    my $TYPE='package';
    foreach (@$specptr) {
	if (/^\s*\%(\w+)(?:\s+(\S+))?\s*$/ && $SECTION{$1}) {
	    #my $NEWTYPE=$1;
	    #my $NEWPACKAGE=$2;
	    push @outpart, RPM::SpecSection->new(RPM=>$rpm, BODY=>$out);#, TYPE=>$TYPE, PACKAGE=>$PACKAGE);
	    $out=[];
	    #$TYPE=$NEWTYPE;
	}
	push @$out, $_;
    }
    push @outpart, RPM::SpecSection->new(RPM=>$rpm, BODY=>$out, TYPE => $TYPE);
    $rpm->{SPECSECTIONS}=\@outpart;
    #foreach (@{$rpm->{SPECSECTIONS}}) {	$_->describe() }
}

sub _get_speclist {
    my $self=shift;
    my @out;
    foreach (@{$self->{SPECSECTIONS}}) {
	push @out, @{$_->get_body()};
    }
    return \@out;
}

sub _set_speclist {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ! ref $ptr eq 'ARRAY';
    $self->_parse_speclist($ptr);
}

sub get_spec {
    my $self=shift;
    return join('',@{$self->_get_speclist()})
}

sub get_section {
    my $self=shift;
    my $type=shift;
    my $pkg=shift;
    if (defined $pkg) {
	foreach my $section (@{$self->{SPECSECTIONS}}) {
	    return $section if $section->get_type() eq $type and $section->get_package() eq $pkg;
	}
    } else {
	foreach my $section (@{$self->{SPECSECTIONS}}) {
	    return $section if $section->get_type() eq $type;
	}
    }
    Carp::carp "section $type $pkg not found!";
    return;
}

sub raw_rename_section {
    my $self=shift;
    my $oldname=shift;
    my $newname=shift;
    foreach my $section (@{$self->{SPECSECTIONS}}) {
	${$section->get_body()}->[0]=~s/(\s*\%\w+\s+)($oldname)\s*/$1$newname/;
    }
    return;
}

sub get_sections {
    my $self=shift;
    #return @{$self->{SPECSECTIONS}};
    return $self->{SPECSECTIONS};
}

sub set_changelog {
    my $self=shift;
    return $self->{CHANGELOG}=shift();
}

sub rpm_custom {
    my $self=shift;
    my $cmd =qq{rpm --define "_specdir $self->{SPECDIR}" --define "_sourcedir $self->{SOURCEDIR}" --define "_srcrpmdir $self->{SRPMDIR}" @_};
    &run($cmd);
}

sub cleanup {
    my $self=shift;
    my $tmpdir=$self->{TMPDIR};
    run("rm -rf $tmpdir") if $tmpdir;
}

sub copy_to_sources {
    my $self=shift;
    foreach my $file (@_) {
	run ("cp -f $file $self->{SOURCEDIR}/");
    }
}

sub basename {
    my @path= split('/',$_[0]);
    return pop @path;
}

sub dirname {
    my @path= split('/',$_[0]);
    pop @path;
    return join('/',@path);
}

sub run {
    my $cmd=shift;
    #print $cmd,"\n";
    system($cmd) && Carp::confess ("$cmd failed: $?");
}

sub load_file {
    my ($name)=@_;
    open FN, $name || die "can't open $name: $!";
    my @result = <FN>;
    close FN, $name || die "can't open $name: $!";
    return \@result;
}

sub write_array_to_file {
    my ($name, $ptr)=@_;
    open FN, '>', $name || die "can't open $name: $!";
    print FN @$ptr;
    close FN, $name || die "can't open $name: $!";
}

sub write_file {
    my ($name, $str)=@_;
    open FN, '>', $name || die "can't open $name: $!";
    print FN $str;
    close FN, $name || die "can't open $name: $!";
}

sub load_macro {
    my $self=shift;
    my $specfile = $self->{SPECFILE};
    my %macro;
    $macro{'nil'}='';
    $macro{'homedir'}=$ENV{'HOME'};
    $macro{'_topsrcdir'}='%_topdir';
    $macro{'_sourcedir'}="%_topsrcdir/SOURCES";
    $macro{'_specdir'}="%_topsrcdir/SPECS";
    $macro{'_srcrpmdir'}="%_topdir/SRPMS";
    if (-e $ENV{'HOME'}.'/.rpmmacros') {
	open (RPMMACROS, $ENV{'HOME'}.'/.rpmmacros') || die "can't open .rpmmacros:$!";
	while (<RPMMACROS>) {
	    if (/^[%]([\w_\/.\d]+)\s+(.+)\s*$/) {
		$macro{$1}=$2 ;
		&macro_subst(\%macro,\$macro{$1});
	    }
	}
	close (RPMMACROS);
    }
    $macro{'_topdir'}||="$ENV{'HOME'}/RPM";
    
    my @source;
    my @patch;
    my @setup_n;
    my @is_setup;
    
    open (SPECFILE, $specfile) || die "can't open spec $specfile: $!";
    while (<SPECFILE>) {
	chomp;
	$macro{'name'}=$1 if /^Name:\s*(.+)$/;
	$macro{'version'}=$1 if /^Version:\s*(.+)$/ and not $macro{'version'};
	$macro{'release'}=$1 if /^Release:\s*(.+)$/ and not $macro{'release'};
	#$macro{$1}=$2 if /^\s*[%]define\s+([\w_\d]+)\s+([\%\{\}\w_\d.-]+)\s*$/;
	$macro{$1}=$2 if /^\s*[%]define\s+([\w_\d]+)\s+(\S+)\s*$/;
	# not needed there
	$source[$1 ? $1 : 0]=$3 if /^Source(\d*):\s*(.+\/)?([^\/]+)$/;
	$patch[$1 ? $1 : 0]=$3 if /^Patch(\d*):\s*(.+\/)?([^\/]+)$/;
	$setup_n[$1 ? $1 : 0] =$3 if /^[%]setup(\d*)\s*(.+)?-n\s+(\S+)/;
	$is_setup[$1 ? $1 : 0] =1 if /^[%]setup(\d*)/;
    }
    close (SPECFILE);

    foreach my $dep (grep {$_} @source, @patch) {
	&macro_subst(\%macro,\$dep);
    }
    #print join("\n",@require),"\n";
    #print join("\n",keys %macro),"\n";

    foreach my $key  
	(qw/
     _sourcedir
     _specdir
     _srcrpmdir
     name
     version
     release
     /) {
	    &macro_subst(\%macro,\$macro{$key});
    }
    $self->{MACRO}=\%macro;
    $self->{SOURCES}=\@source;
    $self->{PATCHES}=\@patch;
    $self->{SETUP_N}=\@setup_n;
    $self->{IS_SETUP}=\@is_setup;
}

sub macro_subst {
    my $macroptr=shift;
    my $argptr=shift;
    #print STDERR "subst: $$argptr\n";
    Carp::cluck "undef" unless defined $$argptr;
    while ($$argptr=~/\%\{?([\w_\d]+)\}?/ and defined $macroptr->{$1}) {
	$$argptr=~s/\%\{?([\w_\d]+)\}?/$macroptr->{$1}/;
    }
}

1;

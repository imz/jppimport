#!/usr/bin/perl -w

#use strict;
use warnings;
use Carp;
use Getopt::Long;

my ($jpprpm,$altrpm,$jppspec,$altspec,$hook,$changelog,$release);
my $verbose=0;
my $srpmdir='.';
my $patchdir=&RPM::ImportTool::dirname($0)."/patches";

my $result = GetOptions ("jpp=s" => \$jpprpm,
		      "alt=s"   => \$altrpm,
		      "jppspec=s" => \$jppspec,
		      "altspec=s"   => \$altspec,
		      "srpmdir=s"   => \$srpmdir,
		      "out=s"   => \$srpmdir,
		      "hook=s"   => \$hook,
		      "changelog=s"   => \$changelog,
		      "release=s"   => \$release,
		      "verbose"  => \$verbose);
my ($alt,$jpp);

if (! $jpprpm && ! $jppspec) {
    print "ERROR: one of --jpp | --jppspec is required!\n";
    print "options:
--jpp /path/to/jpackage.src.rpm
--alt /path/to/altlinux.src.rpm
--jppspec /path/to/jpackage.spec
--altspec /path/to/altlinux.spec
--hook /path/to/hook to be called on resulting spec file
--srpmdir /path/to/output_dir
--out  is the same as --srpmdir
--changelog '- message'
--release 'release' - if we need to adjust the package's release

usage examples:
* convert srpm:
jppimport --alt Sisyphus/antlr-2.7.6-alt1.src.rpm --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm
* convert srpm without history:
jppimport --jpp jpackage/1.7/generic/free/SRPMS/antlr-2.7.7-1jpp.src.rpm --srpmdir ~/OUT
* convert spec:
jppimport --altspec antlr.spec --jppspec jpackage/1.7/generic/free/SPECS/antlr.spec
";
    exit (64);
}

$jpp=RPM::ImportTool->new(RPM => $jpprpm, SPECFILE=> $jppspec, SRPMDIR=> $srpmdir, PATCHDIR=>$patchdir, VERBOSE=> $verbose);

print STDERR "entering alt_generic_fixes\n" if $verbose;
&alt_generic_fix($jpp);
print STDERR "done alt_generic_fixes\n" if $verbose;
&jpp_specific_fix($jpp);
print STDERR "done jpp_specific_fixes\n" if $verbose;

my $altrel="alt1";
my $jpprel = $jpp->get_section('package','')->get_tag('Release');
my $jppver = $jpp->get_section('package','')->get_tag('Version');
if ($altrpm || $altspec) {
    $alt=RPM::ImportTool->new(RPM => $altrpm, SPECFILE => $altspec, VERBOSE=> $verbose);
    $altrel = $alt->get_section('package','')->get_tag('Release');
    $altver = $alt->get_section('package','')->get_tag('Version');
    my $vercmp = `rpmvercmp $altver $jppver`;
    chomp $vercmp;
    $jpp->get_section('changelog')->set_body($alt->get_section('changelog')->get_body());
    if ($altrel=~/^alt([^_]+)_(.+jpp)(\d.\d)$/) {
	my $rel = $1;
	# hack -- cleanup (undefined in jpp) macro in alt release:
	$rel=~s/.?\%\w+//g;
	$rel=~s/.?\%\{\w+\}+//g;
	if ($rel=~/^0\./ or $vercmp != 0) {
	    $rel=1;
	} elsif ($2 eq $jpprel) {
	    $rel=$rel+1;
	}
	$altrel='alt'.$rel;
    } else {
	$altrel=~s/.?\%\w+//g;
	$altrel=~s/.?\%\{\w+\}+//g;
	$altrel='alt1' if $altrel=~/^alt0\./ or $vercmp != 0;
    }
    $alt->cleanup();
}
my $newrel = $altrel."_".$jpprel."1.7";
$newrel=$release if ($release);
$jpp->get_section('package','')->set_tag('Release',$newrel);

# our -- hack ?
our $jpptoolsdir=&RPM::ImportTool::dirname($0);
# for cross-references in hooks
push @INC, $jpptoolsdir."/hooks";

if (not $hook) {
    # looking for default hook
    my $name = $jpp->get_section('package','')->get_tag('Name');
    my $defhook="$jpptoolsdir/hooks/$name.pl";
    # macro_expansion should be here
    #print "looking for default hook $defhook\n";
    $hook = $defhook if (-e $defhook);
}
if ($hook) {
    our @SPECHOOKS;
    our $spechook;
    require $hook;
    if ($spechook or @SPECHOOKS) {
	map {&$_($jpp,$alt)} @SPECHOOKS;
	&$spechook($jpp,$alt) if $spechook;
    } else {
	die "script $hook does not have a valid hook!\n";
    }
}

if ($changelog) {
    $jpp->set_changelog($changelog);
}

print $jpp->get_spec() if $jppspec or $verbose;
$jpp->write_rpm() if $jpprpm;
$jpp->cleanup();

my $TODO=qq~
%if %{native} %if ! %{gcj_support}
BuildRequires:  %{_bindir}/gcj, %{__perl}, 
~;


sub jpp_specific_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    my $main_sec=$rpm->get_section('package','');

    if (not $main_sec->match(qr'BuildRequires: jpackage-1.4-compat')) {
	$main_sec->unshift_body("BuildRequires: jpackage-1.4-compat\n");
	$main_sec->unshift_body("BuildRequires: /proc\n");
    }

    # maven hack
    $main_sec->subst_if(qr'\s+maven(\s|$)',' maven-plugins ', qr'^\s*BuildRequires:\s*');


    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	#print "type is $t\n";
	if ($t eq 'package') {
	    &jpp_specific_cleanup_headers($sec);
	    $sec->subst(
		qr'\%define gcj_support \%{\?_with_gcj_support:1}\%{!\?_with_gcj_support:\%{\?_without_gcj_support:0}\%{!\?_without_gcj_support:\%{\?_gcj_support:\%{_gcj_support}}\%{!\?_gcj_support:0}}}', '%define gcj_support 0');
	} elsif ($t eq 'files') {
	    &jpp_specific_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	} elsif ($t eq 'post') {
	} elsif ($t eq 'postun') {
	} elsif ($t eq 'changelog') {
	}
	# general hacks here
	# altlinux vs redhat incompatibility (found in hsqldb)
	$sec->subst(qr'%{_localstatedir}/lib', '%{_var}/lib');
    }

    # hack... it looks like it should be moved to RPM::ImportTool
    # zip -> bz2 due to alt buggy rpm (/usr/bin/unzip -qL) :(
    $main_sec=$rpm->get_section('package','');
    if ($main_sec->match(qr'^\s*Source\d*:.+\.(zip|jar)\s*$') 
	) {
        # source0 only!! others should be not %setup'ed, or we need explicit check
	#for (my $i=0;$i<@{$rpm->{SOURCES}}; $i++) {
	for (my $i=0;$i<1; $i++) {
	    my $source=$rpm->{SOURCES}->[$i];
	    $source=~s/\s*$//;
	    if ($source=~/\.(zip|jar)$/ and ! $rpm->get_section('prep')->match(qr'unzip -q %{SOURCE'.$i.'\}')) {
		print STDERR "note: try to bzip2 zip source [$source]\n";
		my $sourcefile=$rpm->{SOURCEDIR}."/".&RPM::ImportTool::basename($source);
		if (! -e $sourcefile) {
		    warn "Internal error: source $source not found!";
		} else {
		    my $convertdir= $rpm->{TMPDIR}.'/CONVERT'.$i;
		    mkdir $convertdir;
		    &RPM::ImportTool::run ("pushd $convertdir; unzip -q $sourcefile; popd");
		    my @files= map {s,^\Q$convertdir\E/,,; $_} glob ("$convertdir/*");
		    my @hidden_files=grep {!/\.$/ && ! /\*$/} map {s,^\Q$convertdir\E/,,; $_} glob ("$convertdir/.*");
		    $sourcefile=~s/\.(zip|jar)$/.tar.bz2/;
		    &RPM::ImportTool::run ("tar cjf $sourcefile -C $convertdir @files @hidden_files");
		    my $rawsource=$rpm->{RAWSOURCES}->[$i];
		    my $newsource=$rawsource;
		    $newsource=~s/\.(zip|jar)$/.tar.bz2/;
		    $main_sec->subst(qr"$rawsource",$newsource);
		}
	    }
	}
    }
}

sub jpp_specific_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^\s*\%ghost\s*((?:\%dir|\%doc)\s*)*\%{_javadocdir}/) {
	    # we will leave ghost there... a usual symlink will not upgrade from directory
#	    s,^\s*\%ghost\s*,,g;
	    push @out, $_;
#	} elsif (/^\s*\%ghost\s*\%dir\s*\%{_javadocdir}/) {
	    # throw away -- seems dangerous
#	} elsif (/^\s*\%ghost\s*%{_bindir}/) {
	} elsif (/^\s*\%ghost\s*/) {
	    # alternatives ?
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN { our %JPP_GROUP_MAP = (
"Text Editors", "Editors",
"Utilities", "Utilities",
"Multimedia/Graphics", "Graphics", # batik
"Database", "Databases", # derby
"Applications/Databases", "Databases",
"Networking/Instant messaging", "Networking/Instant messaging", # jext ??? horrible :(
"Internet/Log Analysis", "Monitoring",
"System/Servers", "System/Servers",
"System/Libraries", "System/Libraries", # ht2html
"Text Editors/Integrated Development Environments (IDE)", "Editors",
" ", " ",
	    ); 
}

sub jpp_specific_cleanup_headers {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^Group:(\s*)(.+\S)\s*$/) {
	    #if ($2) eq "System/Libraries" and ht2html
	    if (
		$2 eq "Development/Build Tools"
		or $2 eq "Development/Code Generators"
		or $2 eq "Development/Compilers"
		or $2 eq "Development/Framework"
		or $2 eq "Development/Java"
		or $2 eq "Development/Languages" # ecj
		or $2 eq "Development/Libraries"
		or $2 eq "Development/Libraries/Application Frameworks"
		or $2 eq "Development/LIbraries/Java" # jgroups (bug!)
		or $2 eq "Development/Libraries/Java"
		or $2 eq "Development/libraries/java" # axis2 (bug!)
		or $2 eq "Development/Test/Java"
		or $2 eq "Development/Testing"
		or $2 eq "Development/Tools"
		or $2 eq "Internet/WWW/Dynamic Content" #tomcat
		or $2 eq "Internet/WWW/Servers" #jboss
		or $2 eq "Internet/WWW/Indexing/Search" # lucene
		or $2 eq "Applications/Internet" # apacheds
		or $2 eq "System/Logging" # log4j
		or $2 eq "System/Networking" # mina
		or $2 eq "System Environment/Applications" #tomcat
		or $2 eq "System Environment/Libraries"
		or $2 eq "Security/Cryptography"
		or $2 eq "Software Development/Quality Assurance"
		or $2 eq "Networking/Daemons" # jacarta-common-daemons
		or $2 eq "System/Boot"
		or $2 eq "Text Processing/Markup/XML"
		or $2 eq "Text Processing/Markup/HTML"
		or $2 eq "Documentation" # jacorb
) {
		push @out, "Group:${1}Development/Java\n";
	    } elsif ($JPP_GROUP_MAP{$2}) {
		push @out, "Group:${1}$JPP_GROUP_MAP{$2}\n";
	    } elsif ($2 eq "Development/Documentation") {
		push @out, $_;
	    } else {
		die "unknown conversion for Group: $2";
	    }
	} elsif (/^\s*\%define\s+section\s+free\s*$/) {
	    # throw away
	} elsif (/^\s*((?:BuildRequires|PreReq|BuildPreReq|BuildPrereqs|Requires|Conflicts)\s*(?:\(\w+\))?)\s*:\s*(.*\S)\s*$/) {
	    my $Tag=$1;
	    my $filtered = &filter_pkg_list($2);
	    push @out, "$Tag: $filtered\n" if ($filtered);
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN {
our %DEPSKIP = map {$_ => 1} qw!
%{__make}
/bin/rm /bin/ln
java-devel java
jce jsse 
!;
# java-devel jce jsse ...  are hack around Conflicts: in jpackage-1.x-compat
#jce jsse 


our %DEPSUBST = (
'%{_sbindir}/update-alternatives' => 'alternatives >= 0:0.2.0-alt0.12',
'/usr/sbin/update-alternatives' => 'alternatives >= 0:0.2.0-alt0.12',
'mono-core' => 'mono',
'crimson' => 'jakarta-crimson',
);

}

sub filter_pkg_list {
    my @in = split /[\s,]+/, $_[0];
    my @out;
    while (@in) {
	$_ = shift @in;
	if ($DEPSKIP{$_}) {
	    &read_version(\@in);
	    next;
	} elsif ($DEPSUBST{$_}) {
	    push @out, $DEPSUBST{$_};
	} else {
	    push @out, $_;
	}
    }
    return join(" ",@out)
}

sub read_version {
    my $ptr=shift;
    return if ($#{$ptr}<1);
    if ($ptr->[0] =~/^(?:<|>|=|!=|>=|<=)$/) {
	return (shift @$ptr, shift @$ptr);
    }
    return;
}

sub alt_generic_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    my $cleanroot_pattern='^\s*(rm|%{__rm}) -rf (\$RPM_BUILD_ROOT|\%rpm_build_root)\s*$';
    &alt_generic_check_ahead($secptr->[0]);
    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	if ($t eq 'package') {
	    $sec->exclude('^(Packager|Vendor|Distribution|BuildRoot):');
	} elsif ($t eq 'description') {
	    &alt_generic_fix_desc($sec);
	} elsif ($t eq 'files') {
	    &alt_generic_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	    $sec->exclude($cleanroot_pattern);
	} elsif ($t eq 'clean') {
	    $sec->exclude($cleanroot_pattern);
	    $sec->delete() if ($sec->is_empty());
	} elsif ($t eq 'changelog') {
	    $sec->empty();
	} elsif ($t eq 'post') {
	    &alt_generic_convert_alternatives($rpm,$sec);
	} elsif (($t eq 'postun') or ($t eq 'preun')) {
	    &alt_generic_convert_alternatives($rpm,$sec);
	}
    }
}

# is macro %name used in spec before Name:,Version: tags
# it is not allowed in alt
sub alt_generic_check_ahead {
    my $section=shift;
    my @out;
    my $is_name_passed=0;
    my $is_name_ahead=0;
    foreach (@{$section->get_body()}) {
	m/^\s*Name:/ and $is_name_passed=1; #and print STDERR "passed $_\n";
	$is_name_ahead=1 if m/\%\{name\}/ and $is_name_passed==0;
#print STDERR "AHEAD $_\n";
	$is_name_ahead=1 if m/\%name(?:[^\w\d_]|$)/ and $is_name_passed==0;
#print STDERR "ahead $_\n";
    }
    if ($is_name_ahead) {
	$section->unshift_body('%define name '.$jpp->get_section('package','')->get_tag('Name')."\n");
	$section->unshift_body('%define version '.$jpp->get_section('package','')->get_tag('Version')."\n");
	print STDERR "fixed ahead!!!\n";
    }
}


sub alt_generic_fix_desc {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
# some distro use iso in description. alt use ascii only.
	    #tr/é/e/;
	    tr/éöóêåíãøùçõúôûâàïðîëäæýÿñìèòüáþÉÖÓÊÅÍÃØÙÇÕÚÔÛÂÀÏÐÎËÄÆÝßÑÌÈÒÜÁÞ/eooeaiaoucououaaidieaayvnieouabEOOEAIAOUCOUOUAAIDIEAAYVNIEOUAB/;
	    # % in description
	    s,%(\s|$),%% ,g;
	    push @out, $_;
    }
    $section->set_body(\@out);
}

sub alt_generic_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/^\s*\%attr\(-,root,root\)\s*//;
	#if (/^\s*\%defattr\(0644,root,root,0755\)\s*$/
	if (/^\s*\%defattr\((?:0644|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0664|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0644|-),root,root\)\s*$/
	    ) {
	    # throw away
	} elsif (/^\s*\%defattr\(0755,root,root,0755\)\s*$/) {
	    push @out, "#".$_;
	} elsif (/^\s*\%doc\s*\%\{_docdir\}\s*$/) {
	    push @out, '%doc %{_docdir}/*'."\n";
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub alt_generic_convert_alternatives {
    my $rpm=shift;
    my $section=shift;
    my @out;
    my $ptr = $section->get_body();
    while (@$ptr>0) {
	my $line = shift @$ptr;
	if ($line!~/\s*#/ && $line=~s,^(\s*)(?:(?:\%{_sbindir}|/usr/sbin)/)?update-alternatives --(\w+),,) {
	    my $preline=$1;
	    my $updcmd=$2;
	    $line=&read_multiline($line, $ptr);
	    # the end is abandoned :(
	    if ($updcmd eq "remove") {
		my $name=&read_shell_token(\$line);
		push @out, $preline.'%unregister_alternatives '.&get_alternatives_file_name($rpm,$section,$name)."\n";
	    } elsif ($updcmd eq "install") {
		my $link=&read_shell_token(\$line);
		my $name=&read_shell_token(\$line);
		my $path=&read_shell_token(\$line);
		my $priority=&read_shell_token(\$line);
		my @alternatives=($link,$path,$priority);
		&read_space(\$line);
		while ($line=~/--slave/) {
		    &read_shell_token(\$line);
		    my $slink=&read_shell_token(\$line);
		    my $sname=&read_shell_token(\$line);
		    my $spath=&read_shell_token(\$line);
		    push @alternatives, ($spath,$slink,$path);
		}
		&create_alternatives($rpm,$section, &get_alternatives_file_name($rpm,$section,$name),\@alternatives);
		push @out, $preline.'%register_alternatives '.&get_alternatives_file_name($rpm,$section,$name)."\n";
	    } else {
		push @out, $preline."# unknown update-alternatives --$updcmd\n";
	    }
	} else {
	    push @out, $line;
	}
    }
    $section->set_body(\@out);
}

sub create_alternatives {
    my ($rpm, $section, $alternatives_file_name,$alternativesptr) = @_;
    my @text=('install -d $RPM_BUILD_ROOT/%_altdir; cat >$RPM_BUILD_ROOT/%_altdir/'.$alternatives_file_name.'<<EOF
');
    while (@$alternativesptr>0) {
	my $provided=shift(@$alternativesptr);
	my $alternative=shift(@$alternativesptr);
	my $weight=shift(@$alternativesptr);
	push @text, $provided."\t".$alternative."\t".$weight."\n";
    }
    push @text, "EOF\n";
    $rpm->get_section('install')->push_body(@text);
    $rpm->get_section('files',$section->get_package())->unshift_body('%_altdir/'.$alternatives_file_name."\n");
}

sub get_alternatives_file_name {
    my ($rpm,$section,$name)=@_;
    return $name.'_'.$section->get_package_expanded();
}

sub read_multiline {
    my ($line, $ptr) =@_;
    while (@$ptr>0 && $line=~s/\\[\r\n]+?$//) {
	chomp $line;
#	print "MULTILINE:$line\n";
	$line.=shift(@$ptr);
    }
    return $line;
}

sub read_shell_token {
    my ($lineptr) =@_;
    if ($$lineptr=~s/^\s*(\S+)//) {
	return $1;
    }
    return "";
}

sub read_space {
    my ($lineptr) =@_;
    $$lineptr=~s/^\s*//;
}

package RPM::SpecSection;

sub new {
    my $class = shift;
    my $self= {
	TYPE=> 'package',
	PACKAGE=> '',
	BODY=>[],
	@_
    };
    my $TYPE='package';
    my $PACKAGE='';
    if ($self->{BODY}->[0]=~/^\s*\%(\w+)(?:\s+(.+))?$/ && $RPM::ImportTool::SECTION{$1}) {
	#print "new section: ".$self->{BODY}->[0],"\n";
	$TYPE=$1;
	$PACKAGE=$2;
	$PACKAGE='' unless defined $PACKAGE;
	$PACKAGE=~s/\s*$//;
	$self->{TYPE}=$TYPE;
	$self->{PACKAGE}=$PACKAGE;
    }
    die "Oops! section" if ref $self->{BODY} ne 'ARRAY';
    bless $self, $class;
#    return $self;
}

sub describe {
    my $self=shift;
    print "SpecSection: type=$self->{TYPE}; package=$self->{PACKAGE}; body: ==>\n".join('',@{$self->{BODY}}),"============== END BODY ====================\n";
}

sub get_type {
    my $self=shift;
    return $self->{TYPE};
}

sub get_package {
    my $self=shift;
    return $self->{PACKAGE};
}

sub get_package_expanded {
    my $self=shift;
    my $pkg= $self->{PACKAGE};
    return '%{name}' unless $pkg;
    return $pkg if $pkg=~s/-n\s*//;
    return '%{name}-'.$pkg; 
}

sub get_body {
    my $self=shift;
    return $self->{BODY};
}

sub set_body {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ref $ptr ne 'ARRAY';
    $self->{BODY}=$ptr;
}

sub unshift_body {
    my $self=shift;
    if ($self->is_head_section()) {
	unshift @{$self->{BODY}}, @_;
    } else {
	my $head = shift @{$self->{BODY}};
	unshift @{$self->{BODY}}, $head, @_;
    }
}

sub unshift_body_before_section {
    my $self=shift;
    unshift @{$self->{BODY}}, @_;
}

sub push_body {
    my $self=shift;
    my $bodyptr=$self->{BODY};
    # move pushed item(s) before %if* block of next section
    my @tail;
    my $i=$#{$bodyptr};
    while ($i>=0 and
	       $bodyptr->[$i]=~/^\s*(?:$|\%if)/ # empty line or condition for the next section 
	) {
	unshift @tail, pop @{$bodyptr};
	$i--;
    }
    push @{$bodyptr}, @_, @tail;
}

sub push_body_after {
    my $self=shift;
    my $toinsert = shift;
    my $pattern = shift;
    my $bodyptr=$self->{BODY};
    # move pushed item(s) before %if* block of next section
    my @tail;
    my $i=$#{$bodyptr};
    while ($i>=0 and $bodyptr->[$i]!~/$pattern/ # condition for add
	) {
	unshift @tail, pop @{$bodyptr};
	$i--;
    }

    push @{$bodyptr}, $toinsert, @tail;
}

sub empty {
    my $self=shift;
    $#{$self->{BODY}}=0 if ($#{$self->{BODY}}>0);
}

sub delete {
    my $self=shift;
    $self->{BODY}=[];
}

sub is_empty {
    my $self=shift;
    return 1 if $#{$self->{BODY}}<1;
    foreach (@{$self->{BODY}}[1..$#{$self->{BODY}}]){
	#print "is_empty: [$_]" if ! /^\s*(#.*)?$/;
	return 0 if ! /^\s*(#.*)?$/;
    }
    return 1;
}

sub is_head_section {
    my $self=shift;
    return 1 if $self->{TYPE} eq 'package' && $self->{PACKAGE} eq '';
    return 0;
}

sub exclude {
    my $section=shift;
    my $pattern=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	unless (/$pattern/) {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub subst {
    my $section=shift;
    my $pattern=shift;
    my $replace=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/$pattern/$replace/g;
	push @out, $_;
    }
    $section->set_body(\@out);
}

sub subst_if {
    my $section=shift;
    my $pattern=shift;
    my $replace=shift;
    my $ifpattern=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/$pattern/$replace/g if /$ifpattern/;
	push @out, $_;
    }
    $section->set_body(\@out);
}

sub replace_line {
    my $section=shift;
    my $stringwhat=shift;
    my $stringreplace=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	$_ = $stringreplace if $_ eq $stringwhat;
	push @out, $_;
    }
    $section->set_body(\@out);
}



sub match {
    my $section=shift;
    my $pattern=shift;
    foreach (@{$section->get_body()}) {
	return 1 if /$pattern/;
    }
    return 0;
}

sub get_tag {
    my $section=shift;
    my $tag=shift;
    my %options = (
	RAW=>0,
	@_);
    foreach (@{$section->get_body()}) {
	if (/^$tag\s*:\s*(\S+)\s*$/) {
	    #warn "tag=$tag raw =$1";
	    my $val=$1;
	    if (!$options{RAW}) {
		&RPM::ImportTool::macro_subst_inplace($section->{RPM}->{MACRO},\$val);
	    }
	    return $val;
	}
    }
    return;
}

sub set_tag {
    my ($section, $tag, $val)=@_;
    my $specptr=$section->get_body();
    for (my $i=0; $i<=$#{$specptr}; $i++) {
	if ($specptr->[$i]=~/^$tag:(\s*)/) {
	    $specptr->[$i]="$tag:$1$val\n";
	    last;
	}
    }
    return $section;
}


package RPM::ImportTool;

sub new {
    my $class = shift;
    my $self = {
	CHANGELOG=>'- converted from JPackage by jppimport script',
	PATCHDIR=> '.',
	@_
    };
    bless $self, $class;
    if ($self->{RPM}) {
	if ($self->{RPM}!~/.src.rpm$/ && `file $self->{RPM}`!~/RPM/) {
	    die "$self->{RPM}: not a rpm file!\n";
	}
	my $dirname=&basename($self->{RPM});
	$dirname=~s/.src.rpm//;
	my $pwd= `pwd`;
	chomp $pwd;
	$self->{TMPDIR}||="$pwd/$dirname.$$";
	$self->{SOURCEDIR}||="$self->{TMPDIR}/SOURCES";
	$self->{SPECDIR}||="$self->{TMPDIR}/SPECS";
	$self->{SRPMDIR}||="$self->{TMPDIR}/SRPMS";
	$self->rpm_custom("-i", $self->{RPM});
	$self->{SPECFILE}=(glob "$self->{TMPDIR}/SPECS/*")[0];
    } elsif ($self->{SPECFILE}) {
    } else {
	die "$class: new: either RPM or SPECFILE is required."
    }
    $self->_set_speclist(load_file($self->{SPECFILE}));
    $self->load_macro();
    #print STDERR "done load_macro\n" if $self->{VERBOSE};
    return $self;
}

sub write_rpm {
    my $self=shift;
    my $newdir="$self->{TMPDIR}/NEW";
    mkdir $newdir;
    my $newspec="$newdir/".basename($self->{SPECFILE});
    &write_file($newspec, $self->get_spec());
    run("add_changelog -e '$self->{CHANGELOG}' $newspec");
    $self->rpm_custom('-bs --nodeps', $newspec);
}

BEGIN {
    our %SECTION=map {$_=>1} qw!
package
description
prep
build
install
clean
files
changelog
pre
post
preun
postun
triggerin
triggerun
triggerpostun
!
}

sub _parse_speclist {
    my $rpm=shift;
    my $specptr=shift;
    my @outpart;
    my $out=[];
    my $TYPE='package';
    foreach (@$specptr) {
	if (/^\s*\%(\w+)\s*/ && $SECTION{$1}) {
	    #my $NEWTYPE=$1;
	    push @outpart, RPM::SpecSection->new(RPM=>$rpm, BODY=>$out);#, TYPE=>$TYPE, PACKAGE=>$PACKAGE);
	    $out=[];
	}
	push @$out, $_;
    }
    push @outpart, RPM::SpecSection->new(RPM=>$rpm, BODY=>$out, TYPE => $TYPE);
    $rpm->{SPECSECTIONS}=\@outpart;
    #foreach (@{$rpm->{SPECSECTIONS}}) {	$_->describe() }
}

sub _get_speclist {
    my $self=shift;
    my @out;
    foreach (@{$self->{SPECSECTIONS}}) {
	push @out, @{$_->get_body()};
    }
    return \@out;
}

sub _set_speclist {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ! ref $ptr eq 'ARRAY';
    $self->_parse_speclist($ptr);
}

sub get_spec {
    my $self=shift;
    return join('',@{$self->_get_speclist()})
}

sub get_section {
    my $self=shift;
    my $type=shift;
    my $pkg=shift;
    $pkg='' if (!defined $pkg);
    foreach my $section (@{$self->{SPECSECTIONS}}) {
	return $section if $section->get_type() eq $type and $section->get_package() eq $pkg;
    }
    Carp::carp "section $type $pkg not found!";
    return;
}

sub are_package_names_equal {
    my ($self, $name1, $name2)=@_;
    $name1=~s/^\s*//;
    $name2=~s/^\s*//;
    $name1=~s/\s*$//;
    $name2=~s/\s*$//;
    # TODO: -n handler
    return $name1 eq $name2;
}

sub disable_package {
    my $self=shift;
    my $name=shift;
    $name=~s/^\s*//;
    $name=~s/\s*$//;
    my $keyname=$name;
    $keyname=~s/^.+\s+//;
    unless ($keyname) {
	$keyname='strange_package';
	warn "disable_package: strange name $name";
    }
    
    unless ($name) {
	Carp::carp "main package can't be disabled!\n";
	return;
    }
    $self->{SPECSECTIONS}->[0]->unshift_body('%def_without '.$keyname."\n");
    for (my $i=0; $i<@{$self->{SPECSECTIONS}}; $i++) {
	my $section = $self->{SPECSECTIONS}->[$i];
	if ($self->are_package_names_equal($section->get_package(), $name)) {
	    $section->unshift_body_before_section('%if_with '.$keyname."\n");
	    $section->push_body('%endif #'.$keyname."\n");
	}
    }
    return;
}

sub raw_rename_section {
    my $self=shift;
    my $oldname=shift;
    my $newname=shift;
    foreach my $section (@{$self->{SPECSECTIONS}}) {
	$section->{PACKAGE}=$newname if ($section->get_body()->[0]=~s/(\s*\%\w+\s+)($oldname)\s*/$1$newname\n/);
    }
    return;
}

sub get_sections {
    my $self=shift;
    #return @{$self->{SPECSECTIONS}};
    return $self->{SPECSECTIONS};
}

sub set_changelog {
    my $self=shift;
    return $self->{CHANGELOG}=shift();
}

sub rpm_custom {
    my $self=shift;
    my $cmd =qq{rpm --define "_specdir $self->{SPECDIR}" --define "_sourcedir $self->{SOURCEDIR}" --define "_srcrpmdir $self->{SRPMDIR}" @_};
    &run($cmd);
}

sub cleanup {
    my $self=shift;
    my $tmpdir=$self->{TMPDIR};
    run("rm -rf $tmpdir") if $tmpdir;
}

sub copy_to_sources {
    my $self=shift;
    foreach my $file (@_) {
	run ("cp -f $file $self->{SOURCEDIR}/");
    }
}

sub add_patch {
    my $self=shift;
    my $name=shift;
    my %param = (
	NAME=> $name,
	STRIP => 1,
	NUMBER => 33,
	@_
	);
    # find first unused patch position
    while ($self->{PATCHES}->[$param{NUMBER}]) {$param{NUMBER}++;}
    # register patch
    $self->{PATCHES}->[$param{NUMBER}]=$param{NAME};
    # add patch to spec
    $jpp->get_section('prep')->push_body('%patch'.$param{NUMBER}.' -p'.$param{STRIP}."\n");
    $jpp->get_section('package','')->push_body('Patch'.$param{NUMBER}.': '.$param{NAME}."\n");
    $jpp->copy_to_sources($self->{PATCHDIR}.'/'.$param{NAME});
}

sub basename {
    my @path= split('/',$_[0]);
    return pop @path;
}

sub dirname {
    my @path= split('/',$_[0]);
    pop @path;
    return join('/',@path);
}

sub run {
    my $cmd=shift;
    #print $cmd,"\n";
    system($cmd) && Carp::confess ("$cmd failed: $?");
}

sub load_file {
    my ($name)=@_;
    open FN, $name || die "can't open $name: $!";
    my @result = <FN>;
    close FN, $name || die "can't open $name: $!";
    return \@result;
}

sub write_array_to_file {
    my ($name, $ptr)=@_;
    open FN, '>', $name || die "can't open $name: $!";
    print FN @$ptr;
    close FN, $name || die "can't open $name: $!";
}

sub write_file {
    my ($name, $str)=@_;
    open FN, '>', $name || die "can't open $name: $!";
    print FN $str;
    close FN, $name || die "can't open $name: $!";
}

sub load_macro {
    my $self=shift;
    print STDERR "entering load_macro\n" if $self->{VERBOSE};
    my $specfile = $self->{SPECFILE};
    my %macro;
    $macro{'nil'}='';
    $macro{'homedir'}=$ENV{'HOME'};
    $macro{'_topsrcdir'}='%_topdir';
    $macro{'_sourcedir'}="%_topsrcdir/SOURCES";
    $macro{'_specdir'}="%_topsrcdir/SPECS";
    $macro{'_srcrpmdir'}="%_topdir/SRPMS";
    if (-e $ENV{'HOME'}.'/.rpmmacros') {
	open (RPMMACROS, $ENV{'HOME'}.'/.rpmmacros') || die "can't open .rpmmacros:$!";
	while (<RPMMACROS>) {
	    if (/^[%]([\w_\/.\d]+)\s+(.*\S)\s*$/) {
		$macro{$1}=$2 ;
		&macro_subst_inplace(\%macro,\$macro{$1});
	    }
	}
	close (RPMMACROS);
    }
    $macro{'_topdir'}||="$ENV{'HOME'}/RPM";
    
    my @source;
    my @patch;
    my @setup_n;
    my @is_setup;
    
    open (SPECFILE, $specfile) || die "can't open spec $specfile: $!";
    while (<SPECFILE>) {
	chomp;
	# to avoid recursion Name: %name; old hack is && not $macro{'version'};
	$macro{'name'}=&macro_subst(\%macro, $1) if /^Name\s*:\s*(.*\S)\s*$/;
	$macro{'version'}=&macro_subst(\%macro, $1) if /^Version\s*:\s*(.*\S)\s*$/;
	$macro{'release'}=&macro_subst(\%macro, $1) if /^Release\s*:\s*(.*\S)\s*$/;

	$macro{$1}=$2 if /^\s*[%]define\s+([\w_\d]+)\s+(\S+)\s*$/;
	# not needed there
	$source[$1 ? $1 : 0]=$3 if /^Source(\d*)\s*:\s*(.+\/)?([^\/]+)\s*$/;
	$patch[$1 ? $1 : 0]=$3 if /^Patch(\d*)\s*:\s*(.+\/)?([^\/]+)\s*$/;
	$setup_n[$1 ? $1 : 0] =$3 if /^[%]setup(\d*)\s*(.+)?-n\s+(\S+)/;
	$is_setup[$1 ? $1 : 0] =1 if /^[%]setup(\d*)/;
    }
    close (SPECFILE);

    my @rawsource=@source;
    my @rawpatch=@patch;
    foreach my $dep (grep {$_} @source, @patch) {
	print STDERR "loop3 $dep\n" if $self->{VERBOSE};
	&macro_subst_inplace(\%macro,\$dep);
    }
    #print join("\n",@require),"\n";
    #print join("\n",keys %macro),"\n";

    foreach my $key  
	(qw/
     _sourcedir
     _specdir
     _srcrpmdir
     name
     version
     release
     /) {
	    if (!$macro{$key}) {
		print STDERR "WARNING: undefined $key!\n";
	    }
	    &macro_subst_inplace(\%macro,\$macro{$key});
    }
    $self->{MACRO}=\%macro;
    $self->{SOURCES}=\@source;
    $self->{PATCHES}=\@patch;
    $self->{RAWSOURCES}=\@rawsource;
    $self->{RAWPATCHES}=\@rawpatch;
    $self->{SETUP_N}=\@setup_n;
    $self->{IS_SETUP}=\@is_setup;
}

sub macro_subst {
    my $macroptr=shift;
    my $arg=shift;
    &macro_subst_inplace($macroptr, \$arg);
    #print STDERR "macro subst: $arg\n";
    return $arg;
}


sub macro_subst_inplace {
    my $macroptr=shift;
    my $argptr=shift;
    #print STDERR "subst: $$argptr\n";
    Carp::cluck "undef" unless defined $$argptr;
    while ($$argptr=~/\%\{?([\w_\d]+)\}?/ and defined $macroptr->{$1}) {
	#print STDERR ":: $$argptr\n";
	my $oldval=$$argptr;
	$$argptr=~s/\%\{?([\w_\d]+)\}?/$macroptr->{$1}/;
	if ($oldval eq $$argptr) {
	    warn "macro substitution recursion for ".$oldval."\n";
	    last;
	}
    }
}

1;

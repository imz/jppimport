#!/usr/bin/perl -w

use Getopt::Long;
my ($jpprpm,$altrpm);
my $verbose;
my $srpmdir='.';
my $result = GetOptions ("jpp=s" => \$jpprpm,
		      "alt=s"   => \$altrpm,
		      "srpmdir=s"   => \$srpmdir,
		      "verbose"  => \$verbose);  
my ($alt,$jpp);
$jpp=RPM::ImportTool->new(RPM => $jpprpm, SRPMDIR=> $srpmdir);

&alt_generic_fix($jpp);
&jpp_specific_fix($jpp);

if ($altrpm) {
    $alt=RPM::ImportTool->new(RPM => $altrpm);
    $jpp->get_section('changelog')->set_body($alt->get_section('changelog')->get_body());
    my $newrel = $alt->get_section('package')->get_tag('Release')."_".$jpp->get_section('package')->get_tag('Release')."1.7";
    $jpp->get_section('package')->set_tag('Release',$newrel);
    $alt->cleanup();
}

print $jpp->get_spec();
$jpp->write_rpm();
$jpp->cleanup();

my $TODO=qq~
%if %{native} %if ! %{gcj_support}
BuildRequires:  %{_bindir}/gcj, %{__perl}, 
Requires(postun): %{_sbindir}/update-alternatives
~;


sub jpp_specific_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    $secptr->[0]->unshift_body('%def_without gcj_support'."\n");
    $secptr->[0]->unshift_body("BuildRequires: jpackage-utils\n");
    $secptr->[0]->unshift_body("BuildRequires: /proc\n");
# jdepend; should be detected by peering in SOURCEDIR
    $secptr->[0]->unshift_body("BuildRequires: unzip\n");
# antlr
#    $secptr->[0]->unshift_body("BuildRequires: gcc-c++\n");
    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	if ($t eq 'package') {
	    &jpp_specific_cleanup_headers($sec);
	    $sec->subst(
		qr'\%define gcj_support \%{\?_with_gcj_support:1}\%{!\?_with_gcj_support:\%{\?_without_gcj_support:0}\%{!\?_without_gcj_support:\%{\?_gcj_support:\%{_gcj_support}}\%{!\?_gcj_support:0}}}', '%define gcj_support 0');

# antlr
#	    $sec->subst(
#		qr'\%define native  \%{\?_with_native:1}\%{!\?_without_native:0}', 	'%define native 0');

	} elsif ($t eq 'files') {
	    &jpp_specific_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	} elsif ($t eq 'post') {
	    $sec->subst('\%{_sbindir}/update-alternatives --install', '%register_alternatives');
	} elsif ($t eq 'postun') {
	    $sec->subst('\%{_sbindir}/update-alternatives --remove', '%unregister_alternatives');
	} elsif ($t eq 'changelog') {
	}
    }
}

sub jpp_specific_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
#	if (/^\s*\%ghost\s*\%doc\s*\%{_javadocdir}/ or
#	    /^\s*\%ghost\s*(\%dir\s*)?\%{_javadocdir}/) {
	    # we will make a usual symlink there...
#	    s,^\s*\%ghost\s*,,g;
#	    push @out, $_;
#	} elsif (/^\s*\%ghost\s*\%dir\s*\%{_javadocdir}/) {
	    # throw away -- seems dangerous
#	} elsif (/^\s*\%ghost\s*%{_bindir}/) {
	if (/^\s*\%ghost\s*/) {
	    # alternatives ?
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub jpp_specific_cleanup_headers {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	if (/^Group:(\s*)(.+)\s*$/) {
	    if ($2 eq "Development/Code Generators"
		or $2 eq "Development/Libraries/Java"
) {
		push @out, "Group:${1}Development/Java\n";
	    } elsif ($2 eq "Text Editors") {
		push @out, "Group:${1}Editors\n";
	    } elsif ($2 eq "Development/Documentation") {
		push @out, $_;
	    } else {
		die "unknown conversion for Group: $2";
	    }
	} elsif (/^\s*\%define\s+section\s+free\s*$/) {
	    # throw away
	} elsif (/^\s*((?:BuildRequires|PreReq|BuildPreReq|BuildPrereqs|Requires|Conflicts)(?:\(\w+\))?):\s*(.+)\s*$/) {
	    my $Tag=$1;
	    my $filtered = &filter_pkg_list($2);
	    push @out, "$Tag: $filtered\n" if ($filtered);
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

BEGIN {
our %DEPSKIP = map {$_ => 1} qw!
%{__make}
/bin/rm /bin/ln
java-javadoc
!;
our %DEPSUBST = (
'%{_sbindir}/update-alternatives', 'alternatives >= 0:0.2.0-alt0.12',
'mono-core','mono',
);

}

sub filter_pkg_list {
    my @in = split /[\s,]+/, $_[0];
    my @out;
    while (@in) {
	$_ = shift @in;
	if ($DEPSKIP{$_}) {
	    &read_version(\@in);
	    next;
	} elsif ($DEPSUBST{$_}) {
	    push @out, $DEPSUBST{$_};
	} else {
	    push @out, $_;
	}
    }
    return join(" ",@out)
}

sub read_version {
    my $ptr=shift;
    return if ($#{$ptr}<1);
    if ($ptr->[0] =~/^(?:<|>|=|!=|>=|<=)$/) {
	return (shift @$ptr, shift @$ptr);
    }
    return;
}

sub alt_generic_fix {
    my $rpm=shift;
    my $secptr=$rpm->get_sections();
    my $cleanroot_pattern='^\s*rm -rf (\$RPM_BUILD_ROOT|\%rpm_build_root)\s*$';
    foreach my $sec (@$secptr) {
	my $t = $sec->get_type();
	if ($t eq 'package') {
	    $sec->exclude('^(Packager|Vendor|Distribution|BuildRoot):');
	} elsif ($t eq 'files') {
	    &alt_generic_cleanup_files($sec);
	} elsif ($t eq 'prep' || $t eq 'build' || $t eq 'install') {
	    $sec->exclude($cleanroot_pattern);
	} elsif ($t eq 'clean') {
	    $sec->exclude($cleanroot_pattern);
	    $sec->delete() if ($sec->is_empty());
	} elsif ($t eq 'changelog') {
	    $sec->empty();
	}
    }
}

sub alt_generic_cleanup_files {
    my $section=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/^\s*\%attr\(-,root,root\)\s*//;
	#if (/^\s*\%defattr\(0644,root,root,0755\)\s*$/
	if (/^\s*\%defattr\((?:0644|-),root,root,(?:0755|-)\)\s*$/
	    or /^\s*\%defattr\((?:0644|-),root,root\)\s*$/
	    ) {
	    # throw away
	} elsif (/^\s*\%defattr\(0755,root,root,0755\)\s*$/) {
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}


package RPM::SpecSection;

sub new {
    my $class = shift;
    my $self= {
	TYPE=> 'package',
	BODY=>[],
	@_
    };
    die "Oops! section" if ref $self->{BODY} ne 'ARRAY';
    bless $self, $class;
#    return $self;
}

sub describe {
    my $self=shift;
    print "SpecSection: type=$self->{TYPE}; body:".join('',@{$self->{BODY}}),"============== END BODY ====================\n";
}

sub get_type {
    my $self=shift;
    return $self->{TYPE};
}

sub get_body {
    my $self=shift;
    return $self->{BODY};
}

sub set_body {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ref $ptr ne 'ARRAY';
    $self->{BODY}=$ptr;
}

sub unshift_body {
    my $self=shift;
    unshift @{$self->{BODY}}, @_;
}

sub empty {
    my $self=shift;
    $#{$self->{BODY}}=0 if ($#{$self->{BODY}}>0);
}

sub delete {
    my $self=shift;
    $self->{BODY}=[];
}

sub is_empty {
    my $self=shift;
    return 1 if $#{$self->{BODY}}<1;
    foreach (@{$self->{BODY}}[1..$#{$self->{BODY}}]){
	return 0 if ! /^\s*(#.*)?$/;
    }
    return 1;
}

sub exclude {
    my $section=shift;
    my $pattern=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	unless (/$pattern/) {
	    push @out, $_;
	}
    }
    $section->set_body(\@out);
}

sub subst {
    my $section=shift;
    my $pattern=shift;
    my $replace=shift;
    my @out;
    foreach (@{$section->get_body()}) {
	s/$pattern/$replace/g;
	push @out, $_;
    }
    $section->set_body(\@out);
}

sub get_tag {
    my $section=shift;
    my $tag=shift;
    foreach (@{$section->get_body()}) {
	if (/^$tag:\s*(.+)\s*$/) {
	    return $1;
	}
    }
    return;
}

sub set_tag {
    my ($section, $tag, $val)=@_;
    my $specptr=$section->get_body();
    for (my $i=0; $i<=$#{$specptr}; $i++) {
	if ($specptr->[$i]=~/^$tag:(\s*)/) {
	    $specptr->[$i]="$tag:$1$val\n";
	    last;
	}
    }
    return $section;
}


package RPM::ImportTool;

sub new {
    my $class = shift;
    my $self = {
	@_
    };
    bless $self, $class;
    if ($self->{RPM}) {
	my $dirname=&basename($self->{RPM});
	$dirname=~s/.src.rpm//;
	$self->{TMPDIR}="$dirname.$$";
	$self->rpm_custom("-i", $self->{RPM});
	$self->{SPECFILE}=(glob "$self->{TMPDIR}/SPECS/*")[0];
    } elsif ($self->{SPECFILE}) {
    } else {
	die "$class: new: either RPM or SPECFILE is required."
    }
    $self->_set_speclist(load_file($self->{SPECFILE}));
    return $self;
}

sub write_rpm {
    my $self=shift;
    my $newdir="$self->{TMPDIR}/NEW";
    mkdir $newdir;
    my $newspec="$newdir/".basename($self->{SPECFILE});
    &write_file($newspec, $self->get_spec());
    run("add_changelog -e '- converted from JPackage by jppimport script' $newspec");
    $self->rpm_custom('-bs --nodeps', $newspec);
}

BEGIN {
    our %SECTION=map {$_=>1} qw!
package
description
prep
build
install
clean
files
changelog
pre
post
preun
postun
triggerin
triggerun
triggerpostun
!
}

sub _parse_speclist {
    my $rpm=shift;
    my $specptr=shift;
    my @outpart;
    my $out=[];
    my $TYPE='package';
    foreach (@$specptr) {
	if (/^\s*\%(\w+)/ && $SECTION{$1}) {
	    my $NEWTYPE=$1;
	    push @outpart, RPM::SpecSection->new(RPM=>$rpm, BODY=>$out, TYPE=>$TYPE);
	    $out=[];
	    $TYPE=$NEWTYPE;
	}
	push @$out, $_;
    }
    push @outpart, RPM::SpecSection->new(RPM=>$rpm, BODY=>$out, TYPE => $TYPE);
    $rpm->{SPECSECTIONS}=\@outpart;
#    foreach (@{$rpm->{SPECSECTIONS}}) {
#	$_->describe();
#    }
}

sub _get_speclist {
    my $self=shift;
    my @out;
    foreach (@{$self->{SPECSECTIONS}}) {
	push @out, @{$_->get_body()};
    }
    return \@out;
}

sub _set_speclist {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ! ref $ptr eq 'ARRAY';
    $self->_parse_speclist($ptr);
}

sub get_spec {
    my $self=shift;
    return join('',@{$self->_get_speclist()})
}

sub get_section {
    my $self=shift;
    my $type=shift;
    foreach my $section (@{$self->{SPECSECTIONS}}) {
	return $section if $section->get_type() eq $type;
    }
    return;
}

sub get_sections {
    my $self=shift;
    #return @{$self->{SPECSECTIONS}};
    return $self->{SPECSECTIONS};
}

sub rpm_custom {
    my $self=shift;
    my $tmpdir=$self->{TMPDIR};
    die "Oops! rpm_custom" unless $tmpdir;
    my $pwd= `pwd`;
    chomp $pwd;
    my $SOURCEDIR="$pwd/$tmpdir/SOURCES";
    my $SPECDIR="$pwd/$tmpdir/SPECS";
    my $SRPMDIR="$pwd/$tmpdir/SRPMS";
    $SRPMDIR=$self->{SRPMDIR} if $self->{SRPMDIR};
    my $cmd =qq{rpm --define "_specdir $SPECDIR" --define "_sourcedir $SOURCEDIR" --define "_srcrpmdir $SRPMDIR" @_};
    &run($cmd);
}

sub cleanup {
    my $self=shift;
    my $tmpdir=$self->{TMPDIR};
    run("rm -rf $tmpdir") if $tmpdir;
}

sub basename {
    my @path= split(/\//,$_[0]);
    return pop @path;
}

sub run {
    my $cmd=shift;
    #print $cmd,"\n";
    system($cmd) && die "$cmd failed: $?";
}

sub load_file {
    my ($name)=@_;
    open FN, $name || die "can't open $name: $!";
    my @result = <FN>;
    close FN, $name || die "can't open $name: $!";
    return \@result;
}

sub write_array_to_file {
    my ($name, $ptr)=@_;
    open FN, '>', $name || die "can't open $name: $!";
    print FN @$ptr;
    close FN, $name || die "can't open $name: $!";
}

sub write_file {
    my ($name, $str)=@_;
    open FN, '>', $name || die "can't open $name: $!";
    print FN $str;
    close FN, $name || die "can't open $name: $!";
}

1;

#!/usr/bin/perl -w

#remove %ghost %javadoc

#Group:
#Text Processing/Markup/XML System/Libraries?

use Getopt::Long;
my ($jpprpm,$altrpm);
my $verbose;
my $result = GetOptions ("jpp=s" => \$jpprpm,
		      "alt=s"   => \$altrpm,
		      "verbose"  => \$verbose);  
my ($alt,$jpp);
$jpp=RPM::ImportTool->new(RPM => $jpprpm);

&alt_generic_fix($jpp);
&jpp_specific_fix($jpp);
&cut_changelog($jpp);

if ($altrpm) {
    print "AAA:",$altrpm,"\n";
    $alt=RPM::ImportTool->new(RPM => $altrpm);
    $jpp->set_speclist([@{$jpp->get_speclist()}, @{&get_changelog($alt)}]);
    my $newrel = $alt->get_tag('Release')."_".$jpp->get_tag('Release')."1.7";
    $jpp->set_tag('Release',$newrel);
    $alt->cleanup();
}

print @{$jpp->get_speclist()};
$jpp->cleanup();

my $TODO=qq~
%define gcj_support %{?_with_gcj_support:1}%{!?_with_gcj_support:%{?_without_gcj_support:0}%{!?_without_gcj_support:%{?_gcj_support:%{_gcj_support}}%{!?_gcj_support:0}}}
%define native  %{?_with_native:1}%{!?_without_native:0}
%if %{native} %if ! %{gcj_support}
BuildRequires:  %{_bindir}/gcj, %{__perl}, 
Requires(postun): %{_sbindir}/update-alternatives
Release:        1jpp
~;

sub jpp_specific_fix {
    my $rpm=shift;
    my $specptr=$rpm->get_speclist();
    my @out;
    foreach (@$specptr) {
	if (/^Group:(\s*)(.+)\s*$/) {
	    if ($2 eq "Development/Code Generators") {
		push @out, "Group:${1}Development/Java\n";
	    } elsif ($2 eq "Text Editors") {
		push @out, "Group:${1}Editors\n";
	    } elsif ($2 eq "Development/Documentation") {
		push @out, $_;
	    } else {
		die "unknown conversion for Group: $2";
	    }
	} elsif (/^\s*\%define\s+section\s+free\s*$/) {
	    # throw away
	} elsif (/^\s*\%ghost\s*\%doc\s*%{_javadocdir}/ or
		 /^\s*\%ghost\s*%{_javadocdir}/) {
	    # we will make a usual symlink there...
	    s,^\s*\%ghost\s*,,g;
	    push @out, $_;
	} elsif (/^\s*\%ghost\s*%{_bindir}/
		 ) {
	    # alternatives ?
	    push @out, "#".$_;
	} elsif (/^\s*((?:BuildRequires|Requires|Conflicts)(?:\(\w+\))?):\s*(.+)\s*$/) {
	    my $Tag=$1;
	    my $filtered = &filter_pkg_list($2);
	    push @out, "$Tag: $filtered\n" if ($filtered);
	} elsif (/^\s*\%clean\s*$/) {
	    push @out, "#\%clean\n";
	} else {
	    push @out, $_;
	}
    }
    $rpm->set_speclist(\@out);
}

BEGIN {
our %depskip = map {$_ => 1} qw!
%{__make}
/bin/rm /bin/ln
java-javadoc
!;
}

sub filter_pkg_list {
    my @in = split /[\s,]+/, $_[0];
    my @out;
    while (@in) {
	$_ = shift @in;
	if ($depskip{$_}) {
	    &read_version(\@in);
	    next;
	}
	push @out, $_;
    }
    return join(" ",@out)
}

sub read_version {
    my $ptr=shift;
    return if ($#{$ptr}<1);
    if ($ptr->[0] =~/^(?:<|>|=|!=|>=|<=)$/) {
	return (shift @$ptr, shift @$ptr);
    }
    return;
}

sub alt_generic_fix {
    my $rpm=shift;
    my $specptr=$rpm->get_speclist();
    my @out;
    foreach (@$specptr) {
	s/^\s*\%attr\(-,root,root\)\s*//;
	if (/^(Vendor|Distribution|BuildRoot):/) {
	} elsif (/^\s*rm -rf (\$RPM_BUILD_ROOT|\%rpm_build_root)\s*$/) {
	} elsif (/^\s*\%defattr\(0644,root,root,0755\)\s*$/) {
	    # throw away
	} elsif (/^\s*\%defattr\(0755,root,root,0755\)\s*$/) {
	    push @out, "#".$_;
	} elsif (/^\s*\%clean\s*$/) {
	    push @out, "#".$_;
	} else {
	    push @out, $_;
	}
    }
    $rpm->set_speclist(\@out);
}

sub cut_changelog {
    my $rpm=shift;
    my $specptr=$rpm->get_speclist();
    my @out;
    foreach (@$specptr) {
	if (/^\%changelog/) {
	    push @out, $_;
	    $rpm->set_speclist(\@out);
	    return;
	} else {
	    push @out, $_;
	}
    }
}

sub get_changelog {
    my $rpm=shift;
    my $specptr=$rpm->get_speclist();
    my @spec=@$specptr;
    while (@spec) {
	$_ = shift @spec;
	if (/^\%changelog/) {
	    return [ @spec ];
	}
    }
    return [];
}

package RPM::ImportTool;

sub new {
    my $class = shift;
    my $self = {
	@_
    };
    bless $self, $class;
    if ($self->{RPM}) {
	my @path= split(/\//,$self->{RPM});
	my $dirname=pop @path;
	$dirname=~s/.src.rpm//;
	$self->{TMPDIR}="$dirname.$$";
	$self->rpm_custom("-i", $self->{RPM});
	$self->{SPECFILE}=(glob "$self->{TMPDIR}/SPECS/*")[0];
    } elsif ($self->{SPECFILE}) {
    } else {
	die "$class: new: either RPM or SPECFILE is required."
    }
    $self->{SPEC}=load_file($self->{SPECFILE});
    return $self;
}

sub get_speclist {
    my $self=shift;
    return $self->{SPEC};
}

sub set_speclist {
    my $self=shift;
    my $ptr=shift;
    die "not an array pointer!" if ! ref $ptr eq 'ARRAY';
    $self->{SPEC}=$ptr;
}

sub get_tag {
    my $rpm=shift;
    my $tag=shift;
    my $specptr=$rpm->get_speclist();
    foreach (@$specptr) {
	if (/^$tag:\s*(.+)\s*$/) {
	    return $1;
	}
    }
    return;
}

sub set_tag {
    my ($rpm, $tag, $val)=@_;
    my $specptr=$rpm->get_speclist();
    for (my $i=0; $i<=$#{$specptr}; $i++) {
	if ($specptr->[$i]=~/^$tag:(\s*)/) {
	    $specptr->[$i]="$tag:$1$val\n";
	    last;
	}
    }
    return $rpm;
}


sub rpm_custom {
    my $self=shift;
    my $tmpdir=$self->{TMPDIR};
    die "Oops! rpm_custom" unless $tmpdir;
    my $pwd= `pwd`;
    chomp $pwd;
    my $SOURCEDIR="$pwd/$tmpdir/SOURCES";
    my $SPECDIR="$pwd/$tmpdir/SPECS";
    my $SRPMDIR="$pwd/$tmpdir/SRPMS";
    my $cmd =qq{rpm --define "_specdir $SPECDIR" --define "_sourcedir $SOURCEDIR" --define "_srcrpmdir $SRPMDIR" @_};
    &run($cmd);
}

sub cleanup {
    my $self=shift;
    my $tmpdir=$self->{TMPDIR};
    run("rm -rf $tmpdir") if $tmpdir;
}

sub run {
    my $cmd=shift;
    print $cmd,"\n";
    print `$cmd`;
}

sub load_file {
    my ($name)=@_;
    open FN, $name || die "can't open $name: $!";
    my @result = <FN>;
    close FN, $name || die "can't open $name: $!";
    return \@result;
}
